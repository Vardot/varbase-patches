diff --git a/core/core.services.yml b/core/core.services.yml
index 746bed441a..c707ba1ee0 100644
--- a/core/core.services.yml
+++ b/core/core.services.yml
@@ -65,6 +65,10 @@ parameters:
 services:
   _defaults:
     autoconfigure: true
+  plugin.manager.config_action:
+    class: Drupal\Core\Config\Action\ConfigActionManager
+    parent: default_plugin_manager
+    arguments: ['@config.manager', '@config.storage']
   # Simple cache contexts, directly derived from the request context.
   cache_context.ip:
     class: Drupal\Core\Cache\Context\IpCacheContext
@@ -360,6 +364,14 @@ services:
     public: false
     tags:
       - { name: backend_overridable }
+  config.storage.checkpoint:
+    class: Drupal\Core\Config\Checkpoint\CheckpointStorage
+    arguments: [ '@config.storage', '@config.checkpoints', '@keyvalue' ]
+    tags:
+      - { name: event_subscriber }
+  config.checkpoints:
+    class: Drupal\Core\Config\Checkpoint\LinearHistory
+    arguments: [ '@state', '@datetime.time' ]
   config.import_transformer:
     class: Drupal\Core\Config\ImportStorageTransformer
     arguments: ['@event_dispatcher', '@database', '@lock', '@lock.persistent']
diff --git a/core/lib/Drupal/Core/Config/Action/Annotation/ConfigAction.php b/core/lib/Drupal/Core/Config/Action/Annotation/ConfigAction.php
new file mode 100644
index 0000000000..810ac20564
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Action/Annotation/ConfigAction.php
@@ -0,0 +1,47 @@
+<?php
+
+namespace Drupal\Core\Config\Action\Annotation;
+
+use Drupal\Component\Annotation\Plugin;
+use Drupal\Core\Annotation\Translation;
+use Drupal\Core\StringTranslation\TranslatableMarkup;
+
+/**
+ * Defines a ConfigAction annotation object.
+ *
+ * @ingroup config_action_api
+ *
+ * @Annotation
+ */
+class ConfigAction extends Plugin {
+
+  /**
+   * The plugin ID.
+   *
+   * @var string
+   */
+  public string $id;
+
+  /**
+   * The administrative label of the config action.
+   *
+   * @var \Drupal\Core\Annotation\Translation|\Drupal\Core\StringTranslation\TranslatableMarkup|string
+   *
+   * @ingroup plugin_translatable
+   */
+  public Translation|TranslatableMarkup|string $admin_label = '';
+
+  /**
+   * Allows action shorthand IDs for the listed config entity types.
+   *
+   * If '*' is present in the array then it can apply to all entity types. An
+   * empty array means that shorthand action IDs are not available for this
+   * plugin.
+   *
+   * @see \Drupal\Core\Config\Action\ConfigActionManager::convertActionToPluginId()
+   *
+   * @var string[]
+   */
+  public array $entity_types = [];
+
+}
diff --git a/core/lib/Drupal/Core/Config/Action/Attribute/ActionMethod.php b/core/lib/Drupal/Core/Config/Action/Attribute/ActionMethod.php
new file mode 100644
index 0000000000..0463871b17
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Action/Attribute/ActionMethod.php
@@ -0,0 +1,39 @@
+<?php
+
+namespace Drupal\Core\Config\Action\Attribute;
+
+// cspell:ignore inflector
+use Drupal\Core\Config\Action\Exists;
+use Drupal\Core\StringTranslation\TranslatableMarkup;
+
+/**
+ * @internal
+ *   This API is experimental.
+ */
+#[\Attribute(\Attribute::TARGET_METHOD)]
+final class ActionMethod {
+
+  /**
+   * @param \Drupal\Core\Config\Action\Exists $exists
+   *   Determines behavior of action depending on entity existence.
+   * @param \Drupal\Core\StringTranslation\TranslatableMarkup|string $adminLabel
+   *   The admin label for the user interface.
+   * @param bool|string $pluralize
+   *   Determines whether to create a pluralized version of the method to enable
+   *   the action to be called multiple times before saving the entity. The
+   *   default behavior is to create an action with a plural form as determined
+   *   by \Symfony\Component\String\Inflector\EnglishInflector::pluralize().
+   *   For example, 'grantPermission' has a pluralized version of
+   *   'grantPermissions'. If a string is provided this will be the full action
+   *   ID. For example, if the method is called 'addArray' this can be set to
+   *   'addMultipleArrays'. Set to FALSE if a pluralized version does not make
+   *   logical sense.
+   */
+  public function __construct(
+    public readonly Exists $exists = Exists::ERROR_IF_NOT_EXISTS,
+    public readonly TranslatableMarkup|string $adminLabel = '',
+    public readonly bool|string $pluralize = TRUE
+  ) {
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Config/Action/ConfigActionException.php b/core/lib/Drupal/Core/Config/Action/ConfigActionException.php
new file mode 100644
index 0000000000..02e5220e34
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Action/ConfigActionException.php
@@ -0,0 +1,10 @@
+<?php
+
+namespace Drupal\Core\Config\Action;
+
+/**
+ * @internal
+ *   This API is experimental.
+ */
+final class ConfigActionException extends \RuntimeException {
+}
diff --git a/core/lib/Drupal/Core/Config/Action/ConfigActionManager.php b/core/lib/Drupal/Core/Config/Action/ConfigActionManager.php
new file mode 100644
index 0000000000..539d472631
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Action/ConfigActionManager.php
@@ -0,0 +1,184 @@
+<?php
+
+namespace Drupal\Core\Config\Action;
+
+use Drupal\Component\Plugin\PluginBase;
+use Drupal\Core\Cache\CacheBackendInterface;
+use Drupal\Core\Config\ConfigManagerInterface;
+use Drupal\Core\Config\StorageInterface;
+use Drupal\Core\Extension\ModuleHandlerInterface;
+use Drupal\Core\Plugin\DefaultPluginManager;
+
+/**
+ * @defgroup config_action_api Config Action API
+ * @{
+ * Information about the classes and interfaces that make up the Config Action
+ * API.
+ *
+ * Configuration actions are plugins that manipulate simple configuration or
+ * configuration entities. The configuration action plugin manager can apply
+ * configuration actions. For example, the API is leveraged by recipes to create
+ * roles if they do not exist already and grant permissions to those roles.
+ *
+ * To define a configuration action in a module you need to:
+ * - Define a Config Action plugin by creating a new class that implements the
+ *   \Drupal\Core\Config\Action\ConfigActionPluginInterface, in namespace
+ *   Plugin\ConfigAction under your module namespace. For more information about
+ *   creating plugins, see the @link plugin_api Plugin API topic. @endlink
+ * - Config action plugins use the annotations defined by
+ *  \Drupal\Core\Config\Action\Annotation\ConfigAction. See the
+ *   @link annotation Annotations topic @endlink for more information about
+ *   annotations.
+ *
+ * Further information and examples:
+ * - \Drupal\Core\Config\Action\Plugin\ConfigAction\EntityMethod derives
+ *   configuration actions from config entity methods which have the
+ *   \Drupal\Core\Config\Action\Attribute\ActionMethod attribute.
+ * - \Drupal\Core\Config\Action\Plugin\ConfigAction\EntityCreate allows you to
+ *   create configuration entities if they do not exist.
+ * - \Drupal\Core\Config\Action\Plugin\ConfigAction\SimpleConfigUpdate allows
+ *   you to update simple configuration using a config action.
+ * @}
+ */
+class ConfigActionManager extends DefaultPluginManager {
+
+  /**
+   * Constructs a new \Drupal\Core\Config\Action\ConfigActionManager object.
+   *
+   * @param \Traversable $namespaces
+   *   An object that implements \Traversable which contains the root paths
+   *   keyed by the corresponding namespace to look for plugin implementations.
+   * @param \Drupal\Core\Cache\CacheBackendInterface $cache_backend
+   *   Cache backend instance to use.
+   * @param \Drupal\Core\Extension\ModuleHandlerInterface $module_handler
+   *   The module handler to invoke the alter hook with.
+   * @param \Drupal\Core\Config\ConfigManagerInterface $configManager
+   *   The config manager.
+   * @param \Drupal\Core\Config\StorageInterface $configStorage
+   *   The active config storage.
+   */
+  public function __construct(
+    \Traversable $namespaces,
+    CacheBackendInterface $cache_backend,
+    ModuleHandlerInterface $module_handler,
+    protected readonly ConfigManagerInterface $configManager,
+    protected readonly StorageInterface $configStorage,
+  ) {
+    assert($namespaces instanceof \ArrayAccess, '$namespaces can be accessed like an array');
+    // Enable this namespace to be searched for plugins.
+    $namespaces[__NAMESPACE__] = 'core/lib/Drupal/Core/Config/Action';
+
+    parent::__construct('Plugin/ConfigAction', $namespaces, $module_handler, 'Drupal\Core\Config\Action\ConfigActionPluginInterface', 'Drupal\Core\Config\Action\Annotation\ConfigAction');
+
+    $this->alterInfo('config_action');
+    $this->setCacheBackend($cache_backend, 'config_action');
+  }
+
+  /**
+   * Applies a config action.
+   *
+   * @param string $action_id
+   *   The ID of the action to apply. This can be a complete configuration
+   *   action plugin ID or a shorthand action ID that is available for the
+   *   entity type of the provided configuration name.
+   * @param string $configName
+   *   The configuration name.
+   * @param mixed $data
+   *   The data for the action.
+   *
+   * @throws \Drupal\Component\Plugin\Exception\PluginException
+   *   Thrown when the config action cannot be found.
+   * @throws \Drupal\Core\Config\Action\ConfigActionException
+   *   Thrown when the config action fails to apply.
+   */
+  public function applyAction(string $action_id, string $configName, mixed $data): void {
+    if (!$this->hasDefinition($action_id)) {
+      // Get the full plugin ID from the shorthand map, if it is available.
+      $entity_type = $this->configManager->getEntityTypeIdByName($configName);
+      if ($entity_type) {
+        $action_id = $this->getShorthandActionIdsForEntityType($entity_type)[$action_id] ?? $action_id;
+      }
+    }
+    /** @var \Drupal\Core\Config\Action\ConfigActionPluginInterface $action */
+    $action = $this->createInstance($action_id);
+    foreach ($this->getConfigNamesMatchingExpression($configName) as $name) {
+      $action->apply($name, $data);
+    }
+  }
+
+  /**
+   * Gets the names of all active config objects that match an expression.
+   *
+   * @param string $expression
+   *   The expression to match. This may be the full name of a config object,
+   *   or it may contain wildcards (to target all config entities of a specific
+   *   type, or a subset thereof). For example:
+   *   - `user.role.*` would target all user roles.
+   *   - `user.role.anonymous` would target only the anonymous user role.
+   *   - `core.entity_view_display.node.*.default` would target the default
+   *     view display of every content type.
+   *   - `core.entity_form_display.*.*.default` would target the default form
+   *     display of every bundle of every entity type.
+   *   The expression MUST begin with the prefix of a config entity type --
+   *   for example, `field.field.` in the case of fields, or `user.role.` for
+   *   user roles. The prefix cannot contain wildcards.
+   *
+   * @return string[]
+   *   The names of all active config objects that match the expression.
+   *
+   * @throws \Drupal\Core\Config\Action\ConfigActionException
+   *   Thrown if the expression does not match any known config entity type's
+   *   prefix, or if the expression cannot be parsed.
+   */
+  private function getConfigNamesMatchingExpression(string $expression): array {
+    // If there are no wildcards, we can return the config name as-is.
+    if (!str_contains($expression, '.*')) {
+      return [$expression];
+    }
+
+    $entity_type = $this->configManager->getEntityTypeIdByName($expression);
+    if (empty($entity_type)) {
+      throw new ConfigActionException("No installed config entity type uses the prefix in the expression '$expression'. Either there is a typo in the expression or this recipe should install an additional module or depend on another recipe.");
+    }
+    /** @var \Drupal\Core\Config\Entity\ConfigEntityTypeInterface $entity_type */
+    $entity_type = $this->configManager->getEntityTypeManager()
+      ->getDefinition($entity_type);
+    $prefix = $entity_type->getConfigPrefix();
+
+    // Convert the expression to a regular expression. We assume that * should
+    // match the characters allowed by
+    // \Drupal\Core\Config\ConfigBase::validateName(), which is permissive.
+    $expression = str_replace('\\*', '[^.:?*<>"\'\/\\\\]+', preg_quote($expression));
+    $matches = @preg_grep("/^$expression$/", $this->configStorage->listAll("$prefix."));
+    if ($matches === FALSE) {
+      throw new ConfigActionException("The expression '$expression' could not be parsed.");
+    }
+    return $matches;
+  }
+
+  /**
+   * Gets a map of shorthand action IDs to plugin IDs for an entity type.
+   *
+   * @param string $entityType
+   *   The entity type ID to get the map for.
+   *
+   * @return string[]
+   *   An array of plugin IDs keyed by shorthand action ID for the provided
+   *   entity type.
+   */
+  protected function getShorthandActionIdsForEntityType(string $entityType): array {
+    $map = [];
+    foreach ($this->getDefinitions() as $plugin_id => $definition) {
+      if (in_array($entityType, $definition['entity_types'], TRUE) || in_array('*', $definition['entity_types'], TRUE)) {
+        $regex = '/' . PluginBase::DERIVATIVE_SEPARATOR . '([^' . PluginBase::DERIVATIVE_SEPARATOR . ']*)$/';
+        $action_id = preg_match($regex, $plugin_id, $matches) ? $matches[1] : $plugin_id;
+        if (isset($map[$action_id])) {
+          throw new DuplicateConfigActionIdException(sprintf('The plugins \'%s\' and \'%s\' both resolve to the same shorthand action ID for the \'%s\' entity type', $plugin_id, $map[$action_id], $entityType));
+        }
+        $map[$action_id] = $plugin_id;
+      }
+    }
+    return $map;
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Config/Action/ConfigActionPluginInterface.php b/core/lib/Drupal/Core/Config/Action/ConfigActionPluginInterface.php
new file mode 100644
index 0000000000..143ce3a3d2
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Action/ConfigActionPluginInterface.php
@@ -0,0 +1,19 @@
+<?php
+
+namespace Drupal\Core\Config\Action;
+
+interface ConfigActionPluginInterface {
+
+  /**
+   * Applies the config action.
+   *
+   * @param string $configName
+   *   The name of the config to apply the action to.
+   * @param mixed $value
+   *   The value for the action to use.
+   *
+   * @throws ConfigActionException
+   */
+  public function apply(string $configName, mixed $value): void;
+
+}
diff --git a/core/lib/Drupal/Core/Config/Action/DuplicateConfigActionIdException.php b/core/lib/Drupal/Core/Config/Action/DuplicateConfigActionIdException.php
new file mode 100644
index 0000000000..7f6bdd3f0e
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Action/DuplicateConfigActionIdException.php
@@ -0,0 +1,9 @@
+<?php
+
+namespace Drupal\Core\Config\Action;
+
+/**
+ * Exception thrown if there are conflicting shorthand action IDs.
+ */
+class DuplicateConfigActionIdException extends \RuntimeException {
+}
diff --git a/core/lib/Drupal/Core/Config/Action/EntityMethodException.php b/core/lib/Drupal/Core/Config/Action/EntityMethodException.php
new file mode 100644
index 0000000000..3a7b564421
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Action/EntityMethodException.php
@@ -0,0 +1,10 @@
+<?php
+
+namespace Drupal\Core\Config\Action;
+
+/**
+ * @internal
+ *   This API is experimental.
+ */
+final class EntityMethodException extends \RuntimeException {
+}
diff --git a/core/lib/Drupal/Core/Config/Action/Exists.php b/core/lib/Drupal/Core/Config/Action/Exists.php
new file mode 100644
index 0000000000..ec34b5740d
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Action/Exists.php
@@ -0,0 +1,42 @@
+<?php
+// phpcs:ignoreFile
+
+namespace Drupal\Core\Config\Action;
+
+use Drupal\Core\Config\Entity\ConfigEntityInterface;
+
+/**
+ * @internal
+ *   This API is experimental.
+ */
+enum Exists {
+  case ERROR_IF_EXISTS;
+  case ERROR_IF_NOT_EXISTS;
+  case RETURN_EARLY_IF_EXISTS;
+  case RETURN_EARLY_IF_NOT_EXISTS;
+
+  /**
+   * Determines if an action should return early depending on $entity.
+   *
+   * @param string $configName
+   *   The config name supplied to the action.
+   * @param \Drupal\Core\Config\Entity\ConfigEntityInterface|null $entity
+   *   The entity, if it exists.
+   *
+   * @return bool
+   *   TRUE if the action should return early, FALSE if not.
+   *
+   * @throws \Drupal\Core\Config\Action\ConfigActionException
+   *   Thrown depending on $entity and the value of $this.
+   */
+  public function returnEarly(string $configName, ?ConfigEntityInterface $entity): bool {
+    return match (TRUE) {
+      $this === self::RETURN_EARLY_IF_EXISTS && $entity !== NULL,
+      $this === self::RETURN_EARLY_IF_NOT_EXISTS && $entity === NULL => TRUE,
+      $this === self::ERROR_IF_EXISTS && $entity !== NULL => throw new ConfigActionException(sprintf('Entity %s exists', $configName)),
+      $this === self::ERROR_IF_NOT_EXISTS && $entity === NULL => throw new ConfigActionException(sprintf('Entity %s does not exist', $configName)),
+      default => FALSE
+    };
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Config/Action/Plugin/ConfigAction/Deriver/EntityCreateDeriver.php b/core/lib/Drupal/Core/Config/Action/Plugin/ConfigAction/Deriver/EntityCreateDeriver.php
new file mode 100644
index 0000000000..8f42f7ad9a
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Action/Plugin/ConfigAction/Deriver/EntityCreateDeriver.php
@@ -0,0 +1,32 @@
+<?php
+
+namespace Drupal\Core\Config\Action\Plugin\ConfigAction\Deriver;
+
+use Drupal\Component\Plugin\Derivative\DeriverBase;
+use Drupal\Core\Config\Action\Exists;
+use Drupal\Core\StringTranslation\StringTranslationTrait;
+
+/**
+ * @internal
+ *   This API is experimental.
+ */
+class EntityCreateDeriver extends DeriverBase {
+  use StringTranslationTrait;
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getDerivativeDefinitions($base_plugin_definition) {
+    // These derivatives apply to all entity types.
+    $base_plugin_definition['entity_types'] = ['*'];
+
+    $this->derivatives['ensure_exists'] = $base_plugin_definition + ['constructor_args' => ['exists' => Exists::RETURN_EARLY_IF_EXISTS]];
+    $this->derivatives['ensure_exists']['admin_label'] = $this->t('Ensure entity exists');
+
+    $this->derivatives['create'] = $base_plugin_definition + ['constructor_args' => ['exists' => Exists::ERROR_IF_EXISTS]];
+    $this->derivatives['create']['admin_label'] = $this->t('Entity create');
+
+    return $this->derivatives;
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Config/Action/Plugin/ConfigAction/Deriver/EntityMethodDeriver.php b/core/lib/Drupal/Core/Config/Action/Plugin/ConfigAction/Deriver/EntityMethodDeriver.php
new file mode 100644
index 0000000000..fe99550c6c
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Action/Plugin/ConfigAction/Deriver/EntityMethodDeriver.php
@@ -0,0 +1,141 @@
+<?php
+
+namespace Drupal\Core\Config\Action\Plugin\ConfigAction\Deriver;
+
+// cspell:ignore inflector
+use Drupal\Component\Plugin\Derivative\DeriverBase;
+use Drupal\Component\Plugin\PluginBase;
+use Drupal\Core\Config\Action\Attribute\ActionMethod;
+use Drupal\Core\Config\Action\EntityMethodException;
+use Drupal\Core\Config\Entity\ConfigEntityTypeInterface;
+use Drupal\Core\Entity\EntityTypeManagerInterface;
+use Drupal\Core\Plugin\Discovery\ContainerDeriverInterface;
+use Drupal\Core\StringTranslation\StringTranslationTrait;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+use Symfony\Component\String\Inflector\EnglishInflector;
+use Symfony\Component\String\Inflector\InflectorInterface;
+
+/**
+ * Derives config action methods from attributed config entity methods.
+ *
+ * @internal
+ *   This API is experimental.
+ */
+final class EntityMethodDeriver extends DeriverBase implements ContainerDeriverInterface {
+
+  use StringTranslationTrait;
+
+  /**
+   * Inflector to pluralize words.
+   */
+  protected readonly InflectorInterface $inflector;
+
+  /**
+   * Constructs new EntityMethodDeriver.
+   *
+   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entityTypeManager
+   *   The entity type manager.
+   */
+  public function __construct(protected readonly EntityTypeManagerInterface $entityTypeManager) {
+    $this->inflector = new EnglishInflector();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container, $base_plugin_id) {
+    return new static(
+      $container->get('entity_type.manager')
+    );
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getDerivativeDefinitions($base_plugin_definition) {
+    // Scan all the config entity classes for attributes.
+    foreach ($this->entityTypeManager->getDefinitions() as $entity_type) {
+      if ($entity_type instanceof ConfigEntityTypeInterface) {
+        $reflectionClass = new \ReflectionClass($entity_type->getClass());
+        while ($reflectionClass) {
+          foreach ($reflectionClass->getMethods(\ReflectionMethod::IS_PUBLIC) as $method) {
+            // Only process a method if it is declared on the current class.
+            // Methods on the parent class will be processed later. This allows
+            // for a parent to have an attribute and an overriding class does
+            // not need one. For example,
+            // \Drupal\layout_builder\Entity\LayoutBuilderEntityViewDisplay::setComponent()
+            // and \Drupal\Core\Entity\EntityDisplayBase::setComponent().
+            if ($method->getDeclaringClass()->getName() === $reflectionClass->getName()) {
+              foreach ($method->getAttributes(ActionMethod::class) as $attribute) {
+                $this->processMethod($method, $attribute->newInstance(), $entity_type, $base_plugin_definition);
+              }
+            }
+          }
+          $reflectionClass = $reflectionClass->getParentClass();
+        }
+      }
+    }
+    return $this->derivatives;
+  }
+
+  /**
+   * Processes a method to create derivatives.
+   *
+   * @param \ReflectionMethod $method
+   *   The entity method.
+   * @param \Drupal\Core\Config\Action\Attribute\ActionMethod $action_attribute
+   *   The entity method attribute.
+   * @param \Drupal\Core\Config\Entity\ConfigEntityTypeInterface $entity_type
+   *   The entity type.
+   * @param array $derivative
+   *   The base plugin definition that will used to create the derivative.
+   */
+  private function processMethod(\ReflectionMethod $method, ActionMethod $action_attribute, ConfigEntityTypeInterface $entity_type, array $derivative): void {
+    $derivative['admin_label'] = $action_attribute->adminLabel ?: $this->t('@entity_type @method', ['@entity_type' => $entity_type->getLabel(), '@method' => $method->name]);
+    $derivative['constructor_args'] = [
+      'method' => $method->name,
+      'exists' => $action_attribute->exists,
+      'numberOfParams' => $method->getNumberOfParameters(),
+      'numberOfRequiredParams' => $method->getNumberOfRequiredParameters(),
+      'pluralized' => FALSE,
+    ];
+    $derivative['entity_types'] = [$entity_type->id()];
+    // Build a config action identifier from the entity type's config
+    // prefix  and the method name. For example, the Role entity adds a
+    // 'user.role:grantPermission' action.
+    $this->addDerivative($method->name, $entity_type, $derivative, $method->name);
+
+    $pluralized_name = match(TRUE) {
+      is_string($action_attribute->pluralize) => $action_attribute->pluralize,
+      $action_attribute->pluralize === FALSE => '',
+      default => $this->inflector->pluralize($method->name)[0]
+    };
+    // Add a pluralized version of the plugin.
+    if (strlen($pluralized_name) > 0) {
+      $derivative['constructor_args']['pluralized'] = TRUE;
+      $derivative['admin_label'] = $this->t('@admin_label (multiple calls)', ['@admin_label' => $derivative['admin_label']]);
+      $this->addDerivative($pluralized_name, $entity_type, $derivative, $method->name);
+    }
+  }
+
+  /**
+   * Adds a derivative.
+   *
+   * @param string $action_id
+   *   The action ID.
+   * @param \Drupal\Core\Config\Entity\ConfigEntityTypeInterface $entity_type
+   *   The entity type.
+   * @param array $derivative
+   *   The derivative definition.
+   * @param string $methodName
+   *   The method name.
+   */
+  private function addDerivative(string $action_id, ConfigEntityTypeInterface $entity_type, array $derivative, string $methodName): void {
+    $id = $entity_type->getConfigPrefix() . PluginBase::DERIVATIVE_SEPARATOR . $action_id;
+    if (isset($this->derivatives[$id])) {
+      throw new EntityMethodException(sprintf('Duplicate action can not be created for ID \'%s\' for %s::%s(). The existing action is for the ::%s() method', $id, $entity_type->getClass(), $methodName, $this->derivatives[$id]['constructor_args']['method']));
+    }
+    $this->derivatives[$id] = $derivative;
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Config/Action/Plugin/ConfigAction/EntityCreate.php b/core/lib/Drupal/Core/Config/Action/Plugin/ConfigAction/EntityCreate.php
new file mode 100644
index 0000000000..f86f64fb3a
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Action/Plugin/ConfigAction/EntityCreate.php
@@ -0,0 +1,74 @@
+<?php
+
+namespace Drupal\Core\Config\Action\Plugin\ConfigAction;
+
+use Drupal\Core\Config\Action\ConfigActionException;
+use Drupal\Core\Config\Action\ConfigActionPluginInterface;
+use Drupal\Core\Config\Action\Exists;
+use Drupal\Core\Config\ConfigManagerInterface;
+use Drupal\Core\Plugin\ContainerFactoryPluginInterface;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+
+/**
+ * @ConfigAction(
+ *   id = "entity_create",
+ *   deriver = "\Drupal\Core\Config\Action\Plugin\ConfigAction\Deriver\EntityCreateDeriver",
+ * )
+ *
+ * @internal
+ *   This API is experimental.
+ */
+final class EntityCreate implements ConfigActionPluginInterface, ContainerFactoryPluginInterface {
+
+  /**
+   * Constructs a EntityCreate object.
+   *
+   * @param \Drupal\Core\Config\ConfigManagerInterface $configManager
+   *   The config manager.
+   * @param \Drupal\Core\Config\Action\Exists $exists
+   *   Determines behavior of action depending on entity existence.
+   */
+  public function __construct(
+    protected readonly ConfigManagerInterface $configManager,
+    protected readonly Exists $exists
+  ) {
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition): static {
+    assert(is_array($plugin_definition) && is_array($plugin_definition['constructor_args']), '$plugin_definition contains the expected settings');
+    return new static($container->get('config.manager'), ...$plugin_definition['constructor_args']);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function apply(string $configName, mixed $value): void {
+    if (!is_array($value)) {
+      throw new ConfigActionException(sprintf("The value provided to create %s must be an array", $configName));
+    }
+
+    /** @var \Drupal\Core\Config\Entity\ConfigEntityInterface|null $entity */
+    $entity = $this->configManager->loadConfigEntityByName($configName);
+    if ($this->exists->returnEarly($configName, $entity)) {
+      return;
+    }
+
+    $entity_type_manager = $this->configManager->getEntityTypeManager();
+    $entity_type_id = $this->configManager->getEntityTypeIdByName($configName);
+    if ($entity_type_id === NULL) {
+      throw new ConfigActionException(sprintf("Cannot determine a config entity type from %s", $configName));
+    }
+    /** @var \Drupal\Core\Config\Entity\ConfigEntityTypeInterface $entity_type */
+    $entity_type = $entity_type_manager->getDefinition($entity_type_id);
+
+    $id = substr($configName, strlen($entity_type->getConfigPrefix()) + 1);
+    $entity_type_manager
+      ->getStorage($entity_type->id())
+      ->create($value + ['id' => $id])
+      ->save();
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Config/Action/Plugin/ConfigAction/EntityMethod.php b/core/lib/Drupal/Core/Config/Action/Plugin/ConfigAction/EntityMethod.php
new file mode 100644
index 0000000000..a04bd63732
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Action/Plugin/ConfigAction/EntityMethod.php
@@ -0,0 +1,146 @@
+<?php
+
+namespace Drupal\Core\Config\Action\Plugin\ConfigAction;
+
+use Drupal\Core\Config\Action\ConfigActionPluginInterface;
+use Drupal\Core\Config\Action\EntityMethodException;
+use Drupal\Core\Config\Action\Exists;
+use Drupal\Core\Config\ConfigManagerInterface;
+use Drupal\Core\Config\Entity\ConfigEntityInterface;
+use Drupal\Core\Plugin\ContainerFactoryPluginInterface;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+
+/**
+ * Makes config entity methods with the ActionMethod attribute into actions.
+ *
+ * For example, adding the ActionMethod attribute to
+ * \Drupal\user\Entity\Role::grantPermission() allows permissions to be added to
+ * roles via config actions.
+ *
+ * When calling \Drupal\Core\Config\Action\ConfigActionManager::applyAction()
+ * the $data parameter is mapped to the method's arguments using the following
+ * rules:
+ * - If $data is not an array, the method must only have one argument or one
+ *   required argument.
+ * - If $data is an array and the method only accepts a single argument, the
+ *   array will be passed to the first argument.
+ * - If $data is an array and the method accepts more than one argument, $data
+ *   will be unpacked into the method arguments.
+ *
+ * @ConfigAction(
+ *   id = "entity_method",
+ *   deriver = "\Drupal\Core\Config\Action\Plugin\ConfigAction\Deriver\EntityMethodDeriver",
+ * )
+ *
+ * @internal
+ *   This API is experimental.
+ *
+ * @see \Drupal\Core\Config\Action\Attribute\ActionMethod
+ */
+final class EntityMethod implements ConfigActionPluginInterface, ContainerFactoryPluginInterface {
+
+  /**
+   * Constructs a EntityMethod object.
+   *
+   * @param string $pluginId
+   *   The config action plugin ID.
+   * @param \Drupal\Core\Config\ConfigManagerInterface $configManager
+   *   The config manager.
+   * @param string $method
+   *   The method to call on the config entity.
+   * @param \Drupal\Core\Config\Action\Exists $exists
+   *   Determines behavior of action depending on entity existence.
+   * @param int $numberOfParams
+   *   The number of parameters the method has.
+   * @param int $numberOfRequiredParams
+   *   The number of required parameters the method has.
+   * @param bool $pluralized
+   *   Determines whether an array maps to multiple calls.
+   */
+  public function __construct(
+    protected readonly string $pluginId,
+    protected readonly ConfigManagerInterface $configManager,
+    protected readonly string $method,
+    protected readonly Exists $exists,
+    protected readonly int $numberOfParams,
+    protected readonly int $numberOfRequiredParams,
+    protected readonly bool $pluralized
+  ) {
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition): static {
+    assert(is_array($plugin_definition) && is_array($plugin_definition['constructor_args']), '$plugin_definition contains the expected settings');
+    return new static(
+      $plugin_id,
+      $container->get('config.manager'),
+      ...$plugin_definition['constructor_args']
+    );
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function apply(string $configName, mixed $value): void {
+    /** @var \Drupal\Core\Config\Entity\ConfigEntityInterface|null $entity */
+    $entity = $this->configManager->loadConfigEntityByName($configName);
+    if ($this->exists->returnEarly($configName, $entity)) {
+      return;
+    }
+
+    $entity = $this->pluralized ? $this->applyPluralized($entity, $value) : $this->applySingle($entity, $value);
+    $entity->save();
+  }
+
+  /**
+   * Apply the action to entity treating the $values array as multiple calls.
+   *
+   * @param \Drupal\Core\Config\Entity\ConfigEntityInterface $entity
+   *   The entity to apply the action to.
+   * @param mixed $values
+   *   The values for the action to use.
+   *
+   * @return \Drupal\Core\Config\Entity\ConfigEntityInterface
+   *   The unsaved entity with the action applied.
+   */
+  private function applyPluralized(ConfigEntityInterface $entity, mixed $values): ConfigEntityInterface {
+    if (!is_array($values)) {
+      throw new EntityMethodException(sprintf('The pluralized entity method config action \'%s\' requires an array value in order to call %s::%s() multiple times', $this->pluginId, $entity->getEntityType()->getClass(), $this->method));
+    }
+    foreach ($values as $value) {
+      $entity = $this->applySingle($entity, $value);
+    }
+    return $entity;
+  }
+
+  /**
+   * Apply the action to entity treating the $values array a single call.
+   *
+   * @param \Drupal\Core\Config\Entity\ConfigEntityInterface $entity
+   *   The entity to apply the action to.
+   * @param mixed $value
+   *   The value for the action to use.
+   *
+   * @return \Drupal\Core\Config\Entity\ConfigEntityInterface
+   *   The unsaved entity with the action applied.
+   */
+  private function applySingle(ConfigEntityInterface $entity, mixed $value): ConfigEntityInterface {
+    // If $value is not an array then we only support calling the method if the
+    // number of parameters or required parameters is 1. If there is only 1
+    // parameter and $value is an array then assume that the parameter expects
+    // an array.
+    if (!is_array($value) || $this->numberOfParams === 1) {
+      if ($this->numberOfRequiredParams !== 1 && $this->numberOfParams !== 1) {
+        throw new EntityMethodException(sprintf('Entity method config action \'%s\' requires an array value. The number of parameters or required parameters for %s::%s() is not 1', $this->pluginId, $entity->getEntityType()->getClass(), $this->method));
+      }
+      $entity->{$this->method}($value);
+    }
+    else {
+      $entity->{$this->method}(...$value);
+    }
+    return $entity;
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Config/Action/Plugin/ConfigAction/SimpleConfigUpdate.php b/core/lib/Drupal/Core/Config/Action/Plugin/ConfigAction/SimpleConfigUpdate.php
new file mode 100644
index 0000000000..5f46c65a9c
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Action/Plugin/ConfigAction/SimpleConfigUpdate.php
@@ -0,0 +1,60 @@
+<?php
+
+namespace Drupal\Core\Config\Action\Plugin\ConfigAction;
+
+use Drupal\Core\Config\Action\ConfigActionException;
+use Drupal\Core\Config\Action\ConfigActionPluginInterface;
+use Drupal\Core\Config\ConfigFactoryInterface;
+use Drupal\Core\Plugin\ContainerFactoryPluginInterface;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+
+/**
+ * @ConfigAction(
+ *   id = "simple_config_update",
+ *   admin_label = @Translation("Simple configuration update")
+ * )
+ *
+ * @internal
+ *   This API is experimental.
+ */
+final class SimpleConfigUpdate implements ConfigActionPluginInterface, ContainerFactoryPluginInterface {
+
+  /**
+   * Constructs a SimpleConfigUpdate object.
+   *
+   * @param \Drupal\Core\Config\ConfigFactoryInterface $configFactory
+   *   The config factory.
+   */
+  public function __construct(
+    protected readonly ConfigFactoryInterface $configFactory,
+  ) {
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition): static {
+    return new static($container->get('config.factory'));
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function apply(string $configName, mixed $value): void {
+    $config = $this->configFactory->getEditable($configName);
+    // @todo Should we error if this is a config entity?
+    if ($config->isNew()) {
+      throw new ConfigActionException(sprintf('Config %s does not exist so can not be updated', $configName));
+    }
+
+    // Expect $value to be an array whose keys are the config keys to update.
+    if (!is_array($value)) {
+      throw new ConfigActionException(sprintf('Config %s can not be updated because $value is not an array', $configName));
+    }
+    foreach ($value as $key => $value) {
+      $config->set($key, $value);
+    }
+    $config->save();
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Config/Checkpoint/Checkpoint.php b/core/lib/Drupal/Core/Config/Checkpoint/Checkpoint.php
new file mode 100644
index 0000000000..96fa498317
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Checkpoint/Checkpoint.php
@@ -0,0 +1,32 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\Core\Config\Checkpoint;
+
+/**
+ * A value object to store information about a checkpoint.
+ */
+final class Checkpoint {
+
+  /**
+   * Constructs a checkpoint object.
+   *
+   * @param string $id
+   *   The checkpoint's ID.
+   * @param \Stringable|string $label
+   *   The human-readable label.
+   * @param int $timestamp
+   *   The timestamp when the checkpoint was created.
+   * @param string|null $parent
+   *   The ID of the checkpoint's parent.
+   */
+  public function __construct(
+    public readonly string $id,
+    public readonly \Stringable|string $label,
+    public readonly int $timestamp,
+    public readonly ?string $parent,
+  ) {
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Config/Checkpoint/CheckpointExistsException.php b/core/lib/Drupal/Core/Config/Checkpoint/CheckpointExistsException.php
new file mode 100644
index 0000000000..320022f29f
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Checkpoint/CheckpointExistsException.php
@@ -0,0 +1,9 @@
+<?php
+
+namespace Drupal\Core\Config\Checkpoint;
+
+/**
+ * Thrown when trying to add a checkpoint with an ID that already exists.
+ */
+final class CheckpointExistsException extends \RuntimeException {
+}
diff --git a/core/lib/Drupal/Core/Config/Checkpoint/CheckpointListInterface.php b/core/lib/Drupal/Core/Config/Checkpoint/CheckpointListInterface.php
new file mode 100644
index 0000000000..ef60e217c4
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Checkpoint/CheckpointListInterface.php
@@ -0,0 +1,83 @@
+<?php
+
+namespace Drupal\Core\Config\Checkpoint;
+
+/**
+ * Maintains a list of checkpoints.
+ *
+ * @see \Drupal\Core\Config\Checkpoint\Checkpoint
+ *
+ * @phpstan-extends \IteratorAggregate<string, \Drupal\Core\Config\Checkpoint\Checkpoint>
+ */
+interface CheckpointListInterface extends \IteratorAggregate, \Countable {
+
+  /**
+   * Gets the active checkpoint.
+   *
+   * @return \Drupal\Core\Config\Checkpoint\Checkpoint|null
+   *   The active checkpoint or NULL if there are no checkpoints.
+   */
+  public function getActiveCheckpoint(): ?Checkpoint;
+
+  /**
+   * Gets a checkpoint.
+   *
+   * @param string $id
+   *   The checkpoint ID.
+   *
+   * @return \Drupal\Core\Config\Checkpoint\Checkpoint
+   *   The checkpoint.
+   *
+   * @throws \Drupal\Core\Config\Checkpoint\UnknownCheckpointException
+   *   Thrown when the provided checkpoint does not exist.
+   */
+  public function get(string $id): Checkpoint;
+
+  /**
+   * Gets a checkpoint's parents.
+   *
+   * @param string $id
+   *   The checkpoint ID.
+   *
+   * @return iterable<string, \Drupal\Core\Config\Checkpoint\Checkpoint>
+   */
+  public function getParents(string $id): iterable;
+
+  /**
+   * Adds a new checkpoint.
+   *
+   * @param string $id
+   *   The ID of the checkpoint add.
+   * @param string|\Stringable $label
+   *   The checkpoint label.
+   *
+   * @return \Drupal\Core\Config\Checkpoint\Checkpoint
+   *   The new checkpoint, which is now at the end of the checkpoint sequence.
+   *
+   * @throws \Drupal\Core\Config\Checkpoint\CheckpointExistsException
+   *   Thrown when the ID already exists.
+   */
+  public function add(string $id, string|\Stringable $label): Checkpoint;
+
+  /**
+   * Deletes a checkpoint.
+   *
+   * @param string $id
+   *   The ID of the checkpoint to delete up to: only checkpoints after this one
+   *   will remain.
+   *
+   * @return $this
+   *
+   * @throws \Drupal\Core\Config\Checkpoint\UnknownCheckpointException
+   *   Thrown when provided checkpoint ID does not exist.
+   */
+  public function delete(string $id): static;
+
+  /**
+   * Deletes all checkpoints.
+   *
+   * @return $this
+   */
+  public function deleteAll(): static;
+
+}
diff --git a/core/lib/Drupal/Core/Config/Checkpoint/CheckpointStorage.php b/core/lib/Drupal/Core/Config/Checkpoint/CheckpointStorage.php
new file mode 100644
index 0000000000..5ec4a5bd5c
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Checkpoint/CheckpointStorage.php
@@ -0,0 +1,487 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\Core\Config\Checkpoint;
+
+use Drupal\Core\Config\Config;
+use Drupal\Core\Config\ConfigCollectionEvents;
+use Drupal\Core\Config\ConfigCrudEvent;
+use Drupal\Core\Config\ConfigEvents;
+use Drupal\Core\Config\ConfigRenameEvent;
+use Drupal\Core\Config\StorableConfigBase;
+use Drupal\Core\Config\StorageInterface;
+use Drupal\Core\KeyValueStore\KeyValueFactoryInterface;
+use Drupal\Core\KeyValueStore\KeyValueStoreInterface;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+
+/**
+ * Provides a config storage that can make checkpoints.
+ *
+ * This storage wraps the active storage, and provides the ability to take
+ * checkpoints. Once a checkpoint has been created all configuration operations
+ * made after the checkpoint will be recorded, so it is possible to revert to
+ * original state when the checkpoint was taken.
+ *
+ * This class cannot be used to checkpoint another storage since it relies on
+ * events triggered by the configuration system in order to work. It is the
+ * responsibility of the caller to construct this class with the active storage.
+ */
+final class CheckpointStorage implements CheckpointStorageInterface, EventSubscriberInterface {
+
+  /**
+   * Used as prefix to a config checkpoint collection.
+   *
+   * If this code is copied in order to checkpoint a different storage then
+   * this value must be changed.
+   */
+  private const KEY_VALUE_COLLECTION_PREFIX = 'config.checkpoint.';
+
+  /**
+   * Used to store the list of collections in each checkpoint.
+   *
+   * Note this cannot be a valid configuration name.
+   *
+   * @see \Drupal\Core\Config\ConfigBase::validateName()
+   */
+  private const CONFIG_COLLECTION_KEY = 'collections';
+
+  /**
+   * The key value stores that store configuration changed for each checkpoint.
+   *
+   * @var \Drupal\Core\KeyValueStore\KeyValueStoreInterface[]
+   */
+  private array $keyValueStores;
+
+  /**
+   * The checkpoint to read from.
+   *
+   * @var \Drupal\Core\Config\Checkpoint\Checkpoint|null
+   */
+  private ?Checkpoint $readFromCheckpoint = NULL;
+
+  /**
+   * Constructs a CheckpointStorage object.
+   *
+   * @param \Drupal\Core\Config\StorageInterface $activeStorage
+   *   The active configuration storage.
+   * @param \Drupal\Core\Config\Checkpoint\CheckpointListInterface $checkpoints
+   *   The list of checkpoints.
+   * @param \Drupal\Core\KeyValueStore\KeyValueFactoryInterface $keyValueFactory
+   *   The key value factory.
+   * @param string $collection
+   *   (optional) The configuration collection.
+   */
+  public function __construct(
+    private readonly StorageInterface $activeStorage,
+    private readonly CheckpointListInterface $checkpoints,
+    private readonly KeyValueFactoryInterface $keyValueFactory,
+    private readonly string $collection = StorageInterface::DEFAULT_COLLECTION,
+  ) {
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function exists($name) {
+    if (count($this->checkpoints) === 0) {
+      throw new NoCheckpointsException();
+    }
+
+    foreach ($this->getCheckpointsToReadFrom() as $checkpoint) {
+      $in_checkpoint = $this->getKeyValue($checkpoint->id, $this->collection)->get($name);
+      if ($in_checkpoint !== NULL) {
+        // If $in_checkpoint is FALSE then the configuration has been deleted.
+        return $in_checkpoint !== FALSE;
+      }
+    }
+    return $this->activeStorage->exists($name);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function read($name) {
+    $return = $this->readMultiple([$name]);
+    return $return[$name] ?? FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function readMultiple(array $names) {
+    if (count($this->checkpoints) === 0) {
+      throw new NoCheckpointsException();
+    }
+    $return = [];
+
+    foreach ($this->getCheckpointsToReadFrom() as $checkpoint) {
+      $return = array_merge(
+        $return,
+        $this->getKeyValue($checkpoint->id, $this->collection)->getMultiple($names)
+      );
+      // Remove the read names from the list to fetch.
+      $names = array_diff($names, array_keys($return));
+      if (empty($names)) {
+        // All the configuration has been read. Nothing more to do.
+        break;
+      }
+    }
+
+    // Names not found in the checkpoints have not been modified: read from
+    // active storage.
+    if (!empty($names)) {
+      $return = array_merge(
+        $return,
+        $this->activeStorage->readMultiple($names)
+      );
+    }
+
+    // Remove any renamed or new configuration (FALSE has been recorded for
+    // these operations in the checkpoint).
+    // @see ::onConfigRename()
+    // @see ::onConfigSaveAndDelete()
+    return array_filter($return);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function encode($data) {
+    return $this->activeStorage->encode($data);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function decode($raw) {
+    return $this->activeStorage->decode($raw);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function listAll($prefix = '') {
+    if (count($this->checkpoints) === 0) {
+      throw new NoCheckpointsException();
+    }
+
+    $names = $new_configuration = [];
+
+    foreach ($this->getCheckpointsToReadFrom() as $checkpoint) {
+      $checkpoint_names = array_keys(array_filter($this->getKeyValue($checkpoint->id, $this->collection)->getAll(), function (mixed $value, string $name) use (&$new_configuration, $prefix) {
+        if ($name === static::CONFIG_COLLECTION_KEY) {
+          return FALSE;
+        }
+        // Remove any that don't start with the prefix.
+        if ($prefix !== '' && !str_starts_with($name, $prefix)) {
+          return FALSE;
+        }
+        // We've determined in a previous checkpoint that the configuration did
+        // not exist.
+        if (in_array($name, $new_configuration, TRUE)) {
+          return FALSE;
+        }
+        // If the value is FALSE then the configuration was created after the
+        // checkpoint.
+        if ($value === FALSE) {
+          $new_configuration[] = $name;
+          return FALSE;
+        }
+        return TRUE;
+      }, ARRAY_FILTER_USE_BOTH));
+      $names = array_merge($names, $checkpoint_names);
+    }
+
+    // Remove any names that did not exist prior to the checkpoint.
+    $active_names = array_diff($this->activeStorage->listAll($prefix), $new_configuration);
+
+    $names = array_unique(array_merge($names, $active_names));
+    sort($names);
+    return $names;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function createCollection($collection) {
+    $collection = new self(
+      $this->activeStorage->createCollection($collection),
+      $this->checkpoints,
+      $this->keyValueFactory,
+      $collection
+    );
+    // \Drupal\Core\Config\Checkpoint\CheckpointStorage::$readFromCheckpoint is
+    // assigned by reference so that it is  consistent across all collection
+    // objects created from the same initial object.
+    $collection->readFromCheckpoint = &$this->readFromCheckpoint;
+    return $collection;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getAllCollectionNames() {
+    $names = [];
+    foreach ($this->getCheckpointsToReadFrom() as $checkpoint) {
+      $names = array_merge(
+        $names,
+        $this->getKeyValue($checkpoint->id, StorageInterface::DEFAULT_COLLECTION)->get(static::CONFIG_COLLECTION_KEY, [])
+      );
+    }
+    return array_unique(array_merge($this->activeStorage->getAllCollectionNames(), $names));
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getCollectionName() {
+    return $this->collection;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function checkpoint(string|\Stringable $label): Checkpoint {
+    // Generate a new ID based on the state of the current active checkpoint.
+    $active_checkpoint = $this->checkpoints->getActiveCheckpoint();
+    if ($active_checkpoint instanceof Checkpoint) {
+      $collections = $this->getAllCollectionNames();
+      $collections[] = StorageInterface::DEFAULT_COLLECTION;
+      foreach ($collections as $collection) {
+        $current_checkpoint_data[$collection] = $this->getKeyValue($active_checkpoint->id, $collection)->getAll();
+        // Remove the collections key because it is irrelevant.
+        unset($current_checkpoint_data[$collection][static::CONFIG_COLLECTION_KEY]);
+        // If there is no data in the collection then there is no need to hash
+        // the empty array.
+        if (empty($current_checkpoint_data[$collection])) {
+          unset($current_checkpoint_data[$collection]);
+        }
+      }
+
+      if (!empty($current_checkpoint_data)) {
+        // Use json_encode() here because it is both quicker and results in
+        // smaller output than serialize().
+        $id = hash('sha1', ($active_checkpoint->parent ?? '') . json_encode($current_checkpoint_data));
+        $active_checkpoint = $this->checkpoints->add($id, $label);
+      }
+      else {
+        // @todo https://www.drupal.org/project/distributions_recipes/issues/3408523
+        //   Decide on the correct behavior here.
+      }
+    }
+    else {
+      // @todo https://www.drupal.org/project/distributions_recipes/issues/3408525
+      //   Consider options for generating a real fingerprint.
+      $id = hash('sha1', random_bytes(32));
+      $active_checkpoint = $this->checkpoints->add($id, $label);
+    }
+
+    return $active_checkpoint;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setCheckpointToReadFrom(string|Checkpoint $checkpoint_id): static {
+    if ($checkpoint_id instanceof Checkpoint) {
+      $checkpoint_id = $checkpoint_id->id;
+    }
+    $this->readFromCheckpoint = $this->checkpoints->get($checkpoint_id);
+    return $this;
+  }
+
+  /**
+   * Gets the key value storage for the provided checkpoint.
+   *
+   * @param string $checkpoint
+   *   The checkpoint to get the key value storage for.
+   * @param string $collection
+   *   The config collection to get the key value storage for.
+   *
+   * @return \Drupal\Core\KeyValueStore\KeyValueStoreInterface
+   *   The key value storage for the provided checkpoint.
+   */
+  private function getKeyValue(string $checkpoint, string $collection): KeyValueStoreInterface {
+    $checkpoint_key = $checkpoint;
+    if ($collection !== StorageInterface::DEFAULT_COLLECTION) {
+      $checkpoint_key = $collection . '.' . $checkpoint_key;
+    }
+    return $this->keyValueStores[$checkpoint_key] ??= $this->keyValueFactory->get(self::KEY_VALUE_COLLECTION_PREFIX . $checkpoint_key);
+  }
+
+  /**
+   * Gets the checkpoints to read from.
+   *
+   * @return \Traversable<string, \Drupal\Core\Config\Checkpoint\Checkpoint>
+   *   The checkpoints, keyed by ID.
+   */
+  private function getCheckpointsToReadFrom(): \Traversable {
+    $checkpoint = $this->checkpoints->getActiveCheckpoint();
+
+    /** @var \Drupal\Core\Config\Checkpoint\Checkpoint[] $checkpoints_to_read_from */
+    $checkpoints_to_read_from = [$checkpoint];
+    if ($checkpoint->id !== $this->readFromCheckpoint?->id) {
+      // Follow ancestors to find the checkpoint to start reading from.
+      foreach ($this->checkpoints->getParents($checkpoint->id) as $checkpoint) {
+        array_unshift($checkpoints_to_read_from, $checkpoint);
+        if ($checkpoint->id === $this->readFromCheckpoint?->id) {
+          break;
+        }
+      }
+    }
+
+    // Replay in parent to child order.
+    foreach ($checkpoints_to_read_from as $checkpoint) {
+      yield $checkpoint->id => $checkpoint;
+    }
+  }
+
+  /**
+   * Updates checkpoint when configuration is saved.
+   *
+   * @param \Drupal\Core\Config\ConfigCrudEvent $event
+   *   The configuration event.
+   */
+  public function onConfigSaveAndDelete(ConfigCrudEvent $event): void {
+    $active_checkpoint = $this->checkpoints->getActiveCheckpoint();
+    if ($active_checkpoint === NULL) {
+      return;
+    }
+
+    $saved_config = $event->getConfig();
+    $collection = $saved_config->getStorage()->getCollectionName();
+    $this->storeCollectionName($collection);
+
+    $key_value = $this->getKeyValue($active_checkpoint->id, $collection);
+
+    // If we have not yet stored a checkpoint for this configuration we should.
+    if ($key_value->get($saved_config->getName()) === NULL) {
+      $original_data = $this->getOriginalConfig($saved_config);
+      // An empty array indicates that the config has to be new as a sequence
+      // cannot be the root of a config object. We need to make this assumption
+      // because $saved_config->isNew() will always return FALSE here.
+      if (empty($original_data)) {
+        $original_data = FALSE;
+      }
+      // Only save change to state if there is a change, even if it's just keys
+      // being re-ordered.
+      if ($original_data !== $saved_config->getRawData()) {
+        $key_value->set($saved_config->getName(), $original_data);
+      }
+    }
+  }
+
+  /**
+   * Updates checkpoint when configuration is saved.
+   *
+   * @param \Drupal\Core\Config\ConfigRenameEvent $event
+   *   The configuration event.
+   */
+  public function onConfigRename(ConfigRenameEvent $event): void {
+    $active_checkpoint = $this->checkpoints->getActiveCheckpoint();
+    if ($active_checkpoint === NULL) {
+      return;
+    }
+    $collection = $event->getConfig()->getStorage()->getCollectionName();
+    $this->storeCollectionName($collection);
+
+    $key_value = $this->getKeyValue($active_checkpoint->id, $collection);
+
+    $old_name = $event->getOldName();
+
+    // If we have not yet stored a checkpoint for this configuration, store a
+    // complete copy of the original configuration. Note that renames do not
+    // change data but storing the complete data allows
+    // \Drupal\Core\Config\ConfigImporter to track renames using UUIDs.
+    if ($key_value->get($old_name) === NULL) {
+      $key_value->set($old_name, $this->getOriginalConfig($event->getConfig()));
+    }
+
+    // Record that the new name did not exist prior to the checkpoint.
+    $new_name = $event->getConfig()->getName();
+    if ($key_value->get($new_name) === NULL) {
+      $key_value->set($new_name, FALSE);
+    }
+  }
+
+  /**
+   * Gets the original data from the configuration.
+   *
+   * @param \Drupal\Core\Config\StorableConfigBase $config
+   *   The config to get the original data from.
+   *
+   * @return mixed
+   *   The original data.
+   */
+  private function getOriginalConfig(StorableConfigBase $config): mixed {
+    if ($config instanceof Config) {
+      return $config->getOriginal(apply_overrides: FALSE);
+    }
+    return $config->getOriginal();
+  }
+
+  /**
+   * Stores the collection name so the storage knows its own collections.
+   *
+   * @param string $collection
+   *   The name of the collection.
+   */
+  private function storeCollectionName(string $collection): void {
+    // We do not need to store the default collection.
+    if ($collection === StorageInterface::DEFAULT_COLLECTION) {
+      return;
+    }
+
+    $key_value = $this->getKeyValue($this->checkpoints->getActiveCheckpoint()->id, StorageInterface::DEFAULT_COLLECTION);
+    $collections = $key_value->get(static::CONFIG_COLLECTION_KEY, []);
+    assert(is_array($collections));
+    if (in_array($collection, $collections, TRUE)) {
+      return;
+    }
+    $collections[] = $collection;
+    $key_value->set(static::CONFIG_COLLECTION_KEY, $collections);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function getSubscribedEvents(): array {
+    $events[ConfigEvents::SAVE][] = 'onConfigSaveAndDelete';
+    $events[ConfigEvents::DELETE][] = 'onConfigSaveAndDelete';
+    $events[ConfigEvents::RENAME][] = 'onConfigRename';
+    $events[ConfigCollectionEvents::SAVE_IN_COLLECTION][] = 'onConfigSaveAndDelete';
+    $events[ConfigCollectionEvents::DELETE_IN_COLLECTION][] = 'onConfigSaveAndDelete';
+    $events[ConfigCollectionEvents::RENAME_IN_COLLECTION][] = 'onConfigRename';
+    return $events;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function write($name, array $data): never {
+    throw new \BadMethodCallException(__METHOD__ . ' is not allowed on a CheckpointStorage');
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function delete($name): never {
+    throw new \BadMethodCallException(__METHOD__ . ' is not allowed on a CheckpointStorage');
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function rename($name, $new_name): never {
+    throw new \BadMethodCallException(__METHOD__ . ' is not allowed on a CheckpointStorage');
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function deleteAll($prefix = ''): never {
+    throw new \BadMethodCallException(__METHOD__ . ' is not allowed on a CheckpointStorage');
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Config/Checkpoint/CheckpointStorageInterface.php b/core/lib/Drupal/Core/Config/Checkpoint/CheckpointStorageInterface.php
new file mode 100644
index 0000000000..1539cd18d5
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Checkpoint/CheckpointStorageInterface.php
@@ -0,0 +1,43 @@
+<?php
+
+namespace Drupal\Core\Config\Checkpoint;
+
+use Drupal\Core\Config\StorageInterface;
+
+/**
+ * Provides an interface for checkpoint storages.
+ */
+interface CheckpointStorageInterface extends StorageInterface {
+
+  /**
+   * Creates a checkpoint, if required, and returns the active checkpoint.
+   *
+   * If the storage determines that the current active checkpoint would contain
+   * the same information, it does not have to create a new checkpoint.
+   *
+   * @param string|\Stringable $label
+   *   The checkpoint label to use if a new checkpoint is created.
+   *
+   * @return \Drupal\Core\Config\Checkpoint\Checkpoint
+   *   The currently active checkpoint.
+   */
+  public function checkpoint(string|\Stringable $label): Checkpoint;
+
+  /**
+   * Sets the checkpoint to read from.
+   *
+   * Calling read() or readMultiple() will return the configuration data at the
+   * time of the checkpoint that was set here. If none is set, then the
+   * configuration from the initial checkpoint will be returned.
+   *
+   * @param string|\Drupal\Core\Config\Checkpoint\Checkpoint $checkpoint_id
+   *   The checkpoint ID to read from.
+   *
+   * @return $this
+   *
+   * @throws \Drupal\Core\Config\Checkpoint\UnknownCheckpointException
+   *   Thrown when the provided checkpoint does not exist.
+   */
+  public function setCheckpointToReadFrom(string|Checkpoint $checkpoint_id): static;
+
+}
diff --git a/core/lib/Drupal/Core/Config/Checkpoint/LinearHistory.php b/core/lib/Drupal/Core/Config/Checkpoint/LinearHistory.php
new file mode 100644
index 0000000000..65bd02501a
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Checkpoint/LinearHistory.php
@@ -0,0 +1,141 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\Core\Config\Checkpoint;
+
+use Drupal\Component\Datetime\TimeInterface;
+use Drupal\Core\State\StateInterface;
+
+/**
+ * A chronological list of Checkpoint objects.
+ */
+final class LinearHistory implements CheckpointListInterface {
+
+  /**
+   * The store of all the checkpoint names in state.
+   */
+  private const CHECKPOINT_KEY = 'config.checkpoints';
+
+  /**
+   * The active checkpoint.
+   *
+   * In our implementation this is always the last in the list.
+   *
+   * @var \Drupal\Core\Config\Checkpoint\Checkpoint|null
+   */
+  private ?Checkpoint $activeCheckpoint;
+
+  /**
+   * The list of checkpoints, keyed by ID.
+   *
+   * @var \Drupal\Core\Config\Checkpoint\Checkpoint[]
+   */
+  private array $checkpoints;
+
+  /**
+   * Constructs a checkpoints object.
+   *
+   * @param \Drupal\Core\State\StateInterface $state
+   *   The state service.
+   * @param \Drupal\Component\Datetime\TimeInterface $time
+   *   The time service.
+   */
+  public function __construct(
+    private readonly StateInterface $state,
+    private readonly TimeInterface $time,
+  ) {
+    $this->checkpoints = $this->state->get(self::CHECKPOINT_KEY, []);
+    $this->activeCheckpoint = end($this->checkpoints) ?: NULL;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getActiveCheckpoint(): ?Checkpoint {
+    return $this->activeCheckpoint;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function get(string $id): Checkpoint {
+    if (!isset($this->checkpoints[$id])) {
+      throw new UnknownCheckpointException(sprintf('The checkpoint "%s" does not exist', $id));
+    }
+    return $this->checkpoints[$id];
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getParents(string $id): \Traversable {
+    if (!isset($this->checkpoints[$id])) {
+      throw new UnknownCheckpointException(sprintf('The checkpoint "%s" does not exist', $id));
+    }
+    $checkpoint = $this->checkpoints[$id];
+    while ($checkpoint->parent !== NULL) {
+      $checkpoint = $this->get($checkpoint->parent);
+      yield $checkpoint->id => $checkpoint;
+    }
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getIterator(): \Traversable {
+    return new \ArrayIterator($this->checkpoints);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function count(): int {
+    return count($this->checkpoints);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function add(string $id, string|\Stringable $label): Checkpoint {
+    if (isset($this->checkpoints[$id])) {
+      throw new CheckpointExistsException(sprintf('Cannot create a checkpoint with the ID "%s" as it already exists', $id));
+    }
+    $checkpoint = new Checkpoint($id, $label, $this->time->getCurrentTime(), $this->activeCheckpoint?->id);
+    $this->checkpoints[$checkpoint->id] = $checkpoint;
+    $this->activeCheckpoint = $checkpoint;
+    $this->state->set(self::CHECKPOINT_KEY, $this->checkpoints);
+
+    return $checkpoint;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function delete(string $id): static {
+    if (!isset($this->checkpoints[$id])) {
+      throw new UnknownCheckpointException(sprintf('Cannot delete a checkpoint with the ID "%s" as it does not exist', $id));
+    }
+
+    foreach ($this->checkpoints as $key => $checkpoint) {
+      unset($this->checkpoints[$key]);
+      if ($checkpoint->id === $id) {
+        break;
+      }
+    }
+    $this->state->set(self::CHECKPOINT_KEY, $this->checkpoints);
+
+    return $this;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function deleteAll(): static {
+    $this->checkpoints = [];
+    $this->activeCheckpoint = NULL;
+    $this->state->delete(self::CHECKPOINT_KEY);
+    return $this;
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Config/Checkpoint/NoCheckpointsException.php b/core/lib/Drupal/Core/Config/Checkpoint/NoCheckpointsException.php
new file mode 100644
index 0000000000..9a26a2c6ed
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Checkpoint/NoCheckpointsException.php
@@ -0,0 +1,15 @@
+<?php
+
+namespace Drupal\Core\Config\Checkpoint;
+
+/**
+ * Thrown when using the checkpoint storage with no checkpoints.
+ */
+final class NoCheckpointsException extends \RuntimeException {
+
+  /**
+   * {@inheritdoc}
+   */
+  protected $message = 'This storage cannot be read because there are no checkpoints';
+
+}
diff --git a/core/lib/Drupal/Core/Config/Checkpoint/UnknownCheckpointException.php b/core/lib/Drupal/Core/Config/Checkpoint/UnknownCheckpointException.php
new file mode 100644
index 0000000000..1d6dd928f2
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Checkpoint/UnknownCheckpointException.php
@@ -0,0 +1,9 @@
+<?php
+
+namespace Drupal\Core\Config\Checkpoint;
+
+/**
+ * Thrown when trying to access a checkpoint that does not exist.
+ */
+final class UnknownCheckpointException extends \RuntimeException {
+}
diff --git a/core/lib/Drupal/Core/Config/Config.php b/core/lib/Drupal/Core/Config/Config.php
index abcb41fe7e..9048403a2f 100644
--- a/core/lib/Drupal/Core/Config/Config.php
+++ b/core/lib/Drupal/Core/Config/Config.php
@@ -226,7 +226,8 @@ public function save($has_trusted_data = FALSE) {
       Cache::invalidateTags($this->getCacheTags());
     }
     $this->isNew = FALSE;
-    $this->eventDispatcher->dispatch(new ConfigCrudEvent($this), ConfigEvents::SAVE);
+    $event_name = $this->getStorage()->getCollectionName() === StorageInterface::DEFAULT_COLLECTION ? ConfigEvents::SAVE : ConfigCollectionEvents::SAVE_IN_COLLECTION;
+    $this->eventDispatcher->dispatch(new ConfigCrudEvent($this), $event_name);
     $this->originalData = $this->data;
     return $this;
   }
@@ -243,21 +244,12 @@ public function delete() {
     Cache::invalidateTags($this->getCacheTags());
     $this->isNew = TRUE;
     $this->resetOverriddenData();
-    $this->eventDispatcher->dispatch(new ConfigCrudEvent($this), ConfigEvents::DELETE);
+    $event_name = $this->getStorage()->getCollectionName() === StorageInterface::DEFAULT_COLLECTION ? ConfigEvents::DELETE : ConfigCollectionEvents::DELETE_IN_COLLECTION;
+    $this->eventDispatcher->dispatch(new ConfigCrudEvent($this), $event_name);
     $this->originalData = $this->data;
     return $this;
   }
 
-  /**
-   * Gets the raw data without overrides.
-   *
-   * @return array
-   *   The raw data.
-   */
-  public function getRawData() {
-    return $this->data;
-  }
-
   /**
    * Gets original data from this configuration object.
    *
diff --git a/core/lib/Drupal/Core/Config/ConfigCollectionEvents.php b/core/lib/Drupal/Core/Config/ConfigCollectionEvents.php
new file mode 100644
index 0000000000..e965953986
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/ConfigCollectionEvents.php
@@ -0,0 +1,105 @@
+<?php
+
+namespace Drupal\Core\Config;
+
+/**
+ * Defines events for working with configuration collections.
+ *
+ * Configuration collections are often used to store configuration-related
+ * data, like overrides. The use case is determined by the module that provides
+ * the collection. A classic example is to store the translated parts of
+ * various configuration objects. Using a collection allows this data to be
+ * imported and exported alongside regular configuration. It also allows the
+ * data to be created when installing an extension. In both the import/export
+ * and extension installation situations, collection data is stored in
+ * subdirectories.
+ *
+ * @see \Drupal\Core\Config\ConfigCrudEvent
+ */
+final class ConfigCollectionEvents {
+
+  /**
+   * Event dispatched when saving configuration not in the default collection.
+   *
+   * This event allows modules to react whenever an object that extends
+   * \Drupal\Core\Config\StorableConfigBase is saved in a non-default
+   * collection. The event listener method receives a
+   * \Drupal\Core\Config\ConfigCrudEvent instance.
+   *
+   * Note: this event is not used for configuration in the default collection.
+   * See \Drupal\Core\Config\ConfigEvents::SAVE instead.
+   *
+   * @Event
+   *
+   * @var string
+   *
+   * @see \Drupal\Core\Config\ConfigCrudEvent
+   * @see \Drupal\Core\Config\ConfigFactoryOverrideInterface::createConfigObject()
+   * @see \Drupal\language\Config\LanguageConfigOverride::save()
+   *
+   * @see \Drupal\Core\Config\ConfigEvents::SAVE
+   */
+  const SAVE_IN_COLLECTION = 'config.save.collection';
+
+  /**
+   * Event dispatched when deleting configuration not in the default collection.
+   *
+   * This event allows modules to react whenever an object that extends
+   * \Drupal\Core\Config\StorableConfigBase is deleted in a non-default
+   * collection. The event listener method receives a
+   * \Drupal\Core\Config\ConfigCrudEvent instance.
+   *
+   * Note: this event is not used for configuration in the default collection.
+   * See \Drupal\Core\Config\ConfigEvents::DELETE instead.
+   *
+   * @Event
+   *
+   * @see \Drupal\Core\Config\ConfigEvents::DELETE
+   * @see \Drupal\Core\Config\ConfigCrudEvent
+   * @see \Drupal\Core\Config\ConfigFactoryOverrideInterface::createConfigObject()
+   * @see \Drupal\language\Config\LanguageConfigOverride::delete()
+   *
+   * @var string
+   */
+  const DELETE_IN_COLLECTION = 'config.delete.collection';
+
+  /**
+   * Event dispatched when renaming configuration not in the default collection.
+   *
+   * This event allows modules to react whenever an object that extends
+   * \Drupal\Core\Config\StorableConfigBase is renamed in a non-default
+   * collection. The event listener method receives a
+   * \Drupal\Core\Config\ConfigCrudEvent instance.
+   *
+   * Note: this event is not used for configuration in the default collection.
+   * See \Drupal\Core\Config\ConfigEvents::RENAME instead.
+   *
+   * @Event
+   *
+   * @see \Drupal\Core\Config\ConfigEvents::RENAME
+   * @see \Drupal\Core\Config\ConfigCrudEvent
+   * @see \Drupal\Core\Config\ConfigFactoryOverrideInterface::createConfigObject()
+   *
+   * @var string
+   */
+  const RENAME_IN_COLLECTION = 'config.rename.collection';
+
+  /**
+   * Event dispatched to collect information on all config collections.
+   *
+   * This event allows modules to add to the list of configuration collections
+   * retrieved by \Drupal\Core\Config\ConfigManager::getConfigCollectionInfo().
+   * The event listener method receives a
+   * \Drupal\Core\Config\ConfigCollectionInfo instance.
+   *
+   * @Event
+   *
+   * @see \Drupal\Core\Config\ConfigCollectionInfo
+   * @see \Drupal\Core\Config\ConfigManager::getConfigCollectionInfo()
+   * @see \Drupal\Core\Config\ConfigFactoryOverrideBase
+   *
+   * @var string
+   */
+  const COLLECTION_INFO = 'config.collection_info';
+
+}
diff --git a/core/lib/Drupal/Core/Config/ConfigCrudEvent.php b/core/lib/Drupal/Core/Config/ConfigCrudEvent.php
index 639e3031b4..63048bd753 100644
--- a/core/lib/Drupal/Core/Config/ConfigCrudEvent.php
+++ b/core/lib/Drupal/Core/Config/ConfigCrudEvent.php
@@ -19,17 +19,17 @@ class ConfigCrudEvent extends Event {
   /**
    * Constructs a configuration event object.
    *
-   * @param \Drupal\Core\Config\Config $config
+   * @param \Drupal\Core\Config\StorableConfigBase $config
    *   Configuration object.
    */
-  public function __construct(Config $config) {
+  public function __construct(StorableConfigBase $config) {
     $this->config = $config;
   }
 
   /**
    * Gets configuration object.
    *
-   * @return \Drupal\Core\Config\Config
+   * @return \Drupal\Core\Config\StorableConfigBase
    *   The configuration object that caused the event to fire.
    */
   public function getConfig() {
diff --git a/core/lib/Drupal/Core/Config/ConfigEvents.php b/core/lib/Drupal/Core/Config/ConfigEvents.php
index 8aa2d8d65f..ffb186c299 100644
--- a/core/lib/Drupal/Core/Config/ConfigEvents.php
+++ b/core/lib/Drupal/Core/Config/ConfigEvents.php
@@ -140,8 +140,13 @@ final class ConfigEvents {
    * @see \Drupal\Core\Config\ConfigFactoryOverrideBase
    *
    * @var string
+   *
+   * @deprecated in drupal:10.3.0 and is removed from drupal:11.0.0. Use
+   *    \Drupal\Core\Config\ConfigCollectionEvents::COLLECTION_INFO instead.
+   *
+   * @see https://www.drupal.org/node/3406105
    */
-  const COLLECTION_INFO = 'config.collection_info';
+  const COLLECTION_INFO = ConfigCollectionEvents::COLLECTION_INFO;
 
   /**
    * Name of the event fired just before importing configuration.
diff --git a/core/lib/Drupal/Core/Config/ConfigFactory.php b/core/lib/Drupal/Core/Config/ConfigFactory.php
index ef0e22d482..e29c3710cc 100644
--- a/core/lib/Drupal/Core/Config/ConfigFactory.php
+++ b/core/lib/Drupal/Core/Config/ConfigFactory.php
@@ -260,7 +260,8 @@ public function rename($old_name, $new_name) {
 
     // Prime the cache and load the configuration with the correct overrides.
     $config = $this->get($new_name);
-    $this->eventDispatcher->dispatch(new ConfigRenameEvent($config, $old_name), ConfigEvents::RENAME);
+    $event_name = $this->storage->getCollectionName() === StorageInterface::DEFAULT_COLLECTION ? ConfigEvents::RENAME : ConfigCollectionEvents::RENAME_IN_COLLECTION;
+    $this->eventDispatcher->dispatch(new ConfigRenameEvent($config, $old_name), $event_name);
     return $this;
   }
 
diff --git a/core/lib/Drupal/Core/Config/ConfigFactoryOverrideBase.php b/core/lib/Drupal/Core/Config/ConfigFactoryOverrideBase.php
index c859f7f9fc..ac27578a36 100644
--- a/core/lib/Drupal/Core/Config/ConfigFactoryOverrideBase.php
+++ b/core/lib/Drupal/Core/Config/ConfigFactoryOverrideBase.php
@@ -10,7 +10,7 @@
 abstract class ConfigFactoryOverrideBase implements EventSubscriberInterface {
 
   /**
-   * Reacts to the ConfigEvents::COLLECTION_INFO event.
+   * Reacts to the ConfigCollectionEvents::COLLECTION_INFO event.
    *
    * @param \Drupal\Core\Config\ConfigCollectionInfo $collection_info
    *   The configuration collection info event.
@@ -45,7 +45,7 @@ abstract public function onConfigRename(ConfigRenameEvent $event);
    * {@inheritdoc}
    */
   public static function getSubscribedEvents(): array {
-    $events[ConfigEvents::COLLECTION_INFO][] = ['addCollections'];
+    $events[ConfigCollectionEvents::COLLECTION_INFO][] = ['addCollections'];
     $events[ConfigEvents::SAVE][] = ['onConfigSave', 20];
     $events[ConfigEvents::DELETE][] = ['onConfigDelete', 20];
     $events[ConfigEvents::RENAME][] = ['onConfigRename', 20];
diff --git a/core/lib/Drupal/Core/Config/ConfigFactoryOverrideInterface.php b/core/lib/Drupal/Core/Config/ConfigFactoryOverrideInterface.php
index 13a78f8369..110b0c91b7 100644
--- a/core/lib/Drupal/Core/Config/ConfigFactoryOverrideInterface.php
+++ b/core/lib/Drupal/Core/Config/ConfigFactoryOverrideInterface.php
@@ -34,22 +34,32 @@ public function getCacheSuffix();
    * it can have its own implementation of
    * \Drupal\Core\Config\StorableConfigBase. Configuration overriders can link
    * themselves to a configuration collection by listening to the
-   * \Drupal\Core\Config\ConfigEvents::COLLECTION_INFO event and adding the
-   * collections they are responsible for. Doing this will allow installation
-   * and synchronization to use the overrider's implementation of
-   * StorableConfigBase.
+   * \Drupal\Core\Config\ConfigCollectionEvents::COLLECTION_INFO event and
+   * adding the collections they are responsible for. Doing this will allow
+   * installation and synchronization to use the overrider's implementation of
+   * StorableConfigBase. Additionally, the overrider's implementation should
+   * trigger the appropriate event:
+   * - Saving and creating triggers ConfigCollectionEvents::SAVE_IN_COLLECTION.
+   * - Deleting triggers ConfigCollectionEvents::DELETE_IN_COLLECTION.
+   * - Renaming triggers ConfigCollectionEvents::RENAME_IN_COLLECTION.
    *
    * @see \Drupal\Core\Config\ConfigCollectionInfo
    * @see \Drupal\Core\Config\ConfigImporter::importConfig()
    * @see \Drupal\Core\Config\ConfigInstaller::createConfiguration()
+   * @see \Drupal\Core\Config\ConfigCollectionEvents::SAVE_IN_COLLECTION
+   * @see \Drupal\Core\Config\ConfigCollectionEvents::DELETE_IN_COLLECTION
+   * @see \Drupal\Core\Config\ConfigCollectionEvents::RENAME_IN_COLLECTION
    *
    * @param string $name
    *   The configuration object name.
    * @param string $collection
    *   The configuration collection.
    *
-   * @return \Drupal\Core\Config\StorableConfigBase
-   *   The configuration object for the provided name and collection.
+   * @return \Drupal\Core\Config\StorableConfigBase|null
+   *   The configuration object for the provided name and collection. NULL
+   *   should be returned when the overrider does not use configuration
+   *   collections. For example: a module that provides an overrider to avoid
+   *   storing API keys in config would not use collections.
    */
   public function createConfigObject($name, $collection = StorageInterface::DEFAULT_COLLECTION);
 
diff --git a/core/lib/Drupal/Core/Config/ConfigManager.php b/core/lib/Drupal/Core/Config/ConfigManager.php
index 5db500f2fe..fc49f26bc6 100644
--- a/core/lib/Drupal/Core/Config/ConfigManager.php
+++ b/core/lib/Drupal/Core/Config/ConfigManager.php
@@ -220,7 +220,17 @@ public function uninstall($type, $name) {
     // Remove any matching configuration from collections.
     foreach ($this->activeStorage->getAllCollectionNames() as $collection) {
       $collection_storage = $this->activeStorage->createCollection($collection);
-      $collection_storage->deleteAll($name . '.');
+      $overrider = $this->getConfigCollectionInfo()->getOverrideService($collection);
+      foreach ($collection_storage->listAll($name . '.') as $config_name) {
+        if ($overrider) {
+          $config = $overrider->createConfigObject($config_name, $collection);
+        }
+        else {
+          $config = new Config($config_name, $collection_storage, $this->eventDispatcher, $this->typedConfigManager);
+        }
+        $config->initWithData($collection_storage->read($config_name));
+        $config->delete();
+      }
     }
 
     $schema_dir = $this->extensionPathResolver->getPath($type, $name) . '/' . InstallStorage::CONFIG_SCHEMA_DIRECTORY;
@@ -391,7 +401,7 @@ public function getConfigEntitiesToChangeOnDependencyRemoval($type, array $names
   public function getConfigCollectionInfo() {
     if (!isset($this->configCollectionInfo)) {
       $this->configCollectionInfo = new ConfigCollectionInfo();
-      $this->eventDispatcher->dispatch($this->configCollectionInfo, ConfigEvents::COLLECTION_INFO);
+      $this->eventDispatcher->dispatch($this->configCollectionInfo, ConfigCollectionEvents::COLLECTION_INFO);
     }
     return $this->configCollectionInfo;
   }
diff --git a/core/lib/Drupal/Core/Config/ConfigRenameEvent.php b/core/lib/Drupal/Core/Config/ConfigRenameEvent.php
index 8f71559809..ba7441a0fa 100644
--- a/core/lib/Drupal/Core/Config/ConfigRenameEvent.php
+++ b/core/lib/Drupal/Core/Config/ConfigRenameEvent.php
@@ -17,12 +17,12 @@ class ConfigRenameEvent extends ConfigCrudEvent {
   /**
    * Constructs the config rename event.
    *
-   * @param \Drupal\Core\Config\Config $config
+   * @param \Drupal\Core\Config\StorableConfigBase $config
    *   The configuration that has been renamed.
    * @param string $old_name
    *   The old configuration object name.
    */
-  public function __construct(Config $config, $old_name) {
+  public function __construct(StorableConfigBase $config, $old_name) {
     $this->config = $config;
     $this->oldName = $old_name;
   }
diff --git a/core/lib/Drupal/Core/Config/StorableConfigBase.php b/core/lib/Drupal/Core/Config/StorableConfigBase.php
index ae521919d0..750f8f4f5e 100644
--- a/core/lib/Drupal/Core/Config/StorableConfigBase.php
+++ b/core/lib/Drupal/Core/Config/StorableConfigBase.php
@@ -2,6 +2,7 @@
 
 namespace Drupal\Core\Config;
 
+use Drupal\Component\Utility\NestedArray;
 use Drupal\Core\Config\Schema\Ignore;
 use Drupal\Core\Config\Schema\Mapping;
 use Drupal\Core\Config\Schema\Sequence;
@@ -121,6 +122,47 @@ public function getStorage() {
     return $this->storage;
   }
 
+  /**
+   * Gets original data from this configuration object.
+   *
+   * Original data is the data as it is immediately after loading from
+   * configuration storage before any changes. If this is a new configuration
+   * object it will be an empty array.
+   *
+   * @see \Drupal\Core\Config\Config::get()
+   *
+   * @param string $key
+   *   A string that maps to a key within the configuration data.
+   *
+   * @return mixed
+   *   The data that was requested.
+   */
+  public function getOriginal($key = '') {
+    $original_data = $this->originalData;
+
+    if (empty($key)) {
+      return $original_data;
+    }
+
+    $parts = explode('.', $key);
+    if (count($parts) == 1) {
+      return $original_data[$key] ?? NULL;
+    }
+
+    $value = NestedArray::getValue($original_data, $parts, $key_exists);
+    return $key_exists ? $value : NULL;
+  }
+
+  /**
+   * Gets the raw data without any manipulations.
+   *
+   * @return array
+   *   The raw data.
+   */
+  public function getRawData() {
+    return $this->data;
+  }
+
   /**
    * Gets the schema wrapper for the whole configuration object.
    *
diff --git a/core/lib/Drupal/Core/Config/StorageInterface.php b/core/lib/Drupal/Core/Config/StorageInterface.php
index b2e6d4abb0..9a2908cfc7 100644
--- a/core/lib/Drupal/Core/Config/StorageInterface.php
+++ b/core/lib/Drupal/Core/Config/StorageInterface.php
@@ -7,6 +7,11 @@
  *
  * Classes implementing this interface allow reading and writing configuration
  * data from and to the storage.
+ *
+ * Note: this should never be used directly to work with active configuration.
+ * The values returned from it do not have the expected overrides and writing
+ * directly to the storage does not trigger configuration events. Use the
+ * 'config.factory' service and the configuration objects it provides.
  */
 interface StorageInterface {
 
diff --git a/core/lib/Drupal/Core/Entity/EntityDisplayBase.php b/core/lib/Drupal/Core/Entity/EntityDisplayBase.php
index 768835903f..4951ef32d7 100644
--- a/core/lib/Drupal/Core/Entity/EntityDisplayBase.php
+++ b/core/lib/Drupal/Core/Entity/EntityDisplayBase.php
@@ -2,10 +2,12 @@
 
 namespace Drupal\Core\Entity;
 
+use Drupal\Core\Config\Action\Attribute\ActionMethod;
 use Drupal\Core\Config\Entity\ConfigEntityBase;
 use Drupal\Core\Config\Entity\ConfigEntityInterface;
 use Drupal\Core\Field\FieldDefinitionInterface;
 use Drupal\Core\Entity\Display\EntityDisplayInterface;
+use Drupal\Core\StringTranslation\TranslatableMarkup;
 
 /**
  * Provides a common base class for entity view and form displays.
@@ -345,6 +347,7 @@ public function getComponent($name) {
   /**
    * {@inheritdoc}
    */
+  #[ActionMethod(adminLabel: new TranslatableMarkup('Add component to display'))]
   public function setComponent($name, array $options = []) {
     // If no weight specified, make sure the field sinks at the bottom.
     if (!isset($options['weight'])) {
diff --git a/core/lib/Drupal/Core/Field/FieldConfigBase.php b/core/lib/Drupal/Core/Field/FieldConfigBase.php
index ca9a5b5285..610977ec2d 100644
--- a/core/lib/Drupal/Core/Field/FieldConfigBase.php
+++ b/core/lib/Drupal/Core/Field/FieldConfigBase.php
@@ -2,10 +2,12 @@
 
 namespace Drupal\Core\Field;
 
+use Drupal\Core\Config\Action\Attribute\ActionMethod;
 use Drupal\Core\Config\Entity\ConfigEntityBase;
 use Drupal\Core\Entity\EntityStorageInterface;
 use Drupal\Core\Entity\FieldableEntityInterface;
 use Drupal\Core\Field\TypedData\FieldItemDataDefinition;
+use Drupal\Core\StringTranslation\TranslatableMarkup;
 
 /**
  * Base class for configurable field definitions.
@@ -327,6 +329,7 @@ public function getLabel() {
   /**
    * {@inheritdoc}
    */
+  #[ActionMethod(adminLabel: new TranslatableMarkup('Change field label'))]
   public function setLabel($label) {
     $this->label = $label;
     return $this;
diff --git a/core/lib/Drupal/Core/Recipe/ConfigConfigurator.php b/core/lib/Drupal/Core/Recipe/ConfigConfigurator.php
new file mode 100644
index 0000000000..fc3db51ed5
--- /dev/null
+++ b/core/lib/Drupal/Core/Recipe/ConfigConfigurator.php
@@ -0,0 +1,103 @@
+<?php
+
+namespace Drupal\Core\Recipe;
+
+use Drupal\Core\Config\FileStorage;
+use Drupal\Core\Config\StorageInterface;
+
+/**
+ * @internal
+ *   This API is experimental.
+ */
+final class ConfigConfigurator {
+
+  public readonly ?string $recipeConfigDirectory;
+
+  /**
+   * @param array $config
+   *   Config options for a recipe.
+   * @param string $recipe_directory
+   *   The path to the recipe.
+   * @param \Drupal\Core\Config\StorageInterface $active_configuration
+   *   The active configuration storage.
+   */
+  public function __construct(public readonly array $config, string $recipe_directory, StorageInterface $active_configuration) {
+    // @todo validate structure of $config['import'] and $config['actions'].
+
+    $this->recipeConfigDirectory = is_dir($recipe_directory . '/config') ? $recipe_directory . '/config' : NULL;
+    $recipe_storage = $this->getConfigStorage();
+    foreach ($recipe_storage->listAll() as $config_name) {
+      if ($active_data = $active_configuration->read($config_name)) {
+        // @todo investigate if there is any generic code in core for this.
+        unset($active_data['uuid'], $active_data['_core']);
+        if (empty($active_data['dependencies'])) {
+          unset($active_data['dependencies']);
+        }
+        $recipe_data = $recipe_storage->read($config_name);
+        // Ensure we don't get a false mismatch due to differing key order.
+        // @todo When https://www.drupal.org/project/drupal/issues/3230826 is
+        //   fixed in core, use that API instead to sort the config data.
+        self::recursiveSortByKey($active_data);
+        self::recursiveSortByKey($recipe_data);
+        if ($active_data !== $recipe_data) {
+          throw new RecipePreExistingConfigException($config_name, sprintf("The configuration '%s' exists already and does not match the recipe's configuration", $config_name));
+        }
+      }
+    }
+  }
+
+  /**
+   * Sorts an array recursively, by key, alphabetically.
+   *
+   * @param mixed[] $data
+   *   The array to sort, passed by reference.
+   *
+   * @todo Remove when https://www.drupal.org/project/drupal/issues/3230826 is
+   *   fixed in core.
+   */
+  private static function recursiveSortByKey(array &$data): void {
+    // If the array is a list, it is by definition already sorted.
+    if (!array_is_list($data)) {
+      ksort($data);
+    }
+    foreach ($data as &$value) {
+      if (is_array($value)) {
+        self::recursiveSortByKey($value);
+      }
+    }
+  }
+
+  /**
+   * Gets a config storage object for reading config from the recipe.
+   *
+   * @return \Drupal\Core\Config\StorageInterface
+   *   The  config storage object for reading config from the recipe.
+   */
+  public function getConfigStorage(): StorageInterface {
+    $storages = [];
+
+    if ($this->recipeConfigDirectory) {
+      // Config provided by the recipe should take priority over config from
+      // extensions.
+      $storages[] = new FileStorage($this->recipeConfigDirectory);
+    }
+    if (!empty($this->config['import'])) {
+      /** @var \Drupal\Core\Extension\ModuleExtensionList $module_list */
+      $module_list = \Drupal::service('extension.list.module');
+      /** @var \Drupal\Core\Extension\ThemeExtensionList $theme_list */
+      $theme_list = \Drupal::service('extension.list.theme');
+      foreach ($this->config['import'] as $extension => $config) {
+        $path = match (TRUE) {
+          $module_list->exists($extension) => $module_list->getPath($extension),
+          $theme_list->exists($extension) => $theme_list->getPath($extension),
+          default => throw new \RuntimeException("$extension is not a theme or module")
+        };
+        $config = (array) ($config === '*' ? NULL : $config);
+        $storages[] = new RecipeExtensionConfigStorage($path, $config);
+      }
+    }
+
+    return RecipeConfigStorageWrapper::createStorageFromArray($storages);
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Recipe/ContentConfigurator.php b/core/lib/Drupal/Core/Recipe/ContentConfigurator.php
new file mode 100644
index 0000000000..753ecc16d4
--- /dev/null
+++ b/core/lib/Drupal/Core/Recipe/ContentConfigurator.php
@@ -0,0 +1,19 @@
+<?php
+
+namespace Drupal\Core\Recipe;
+
+/**
+ * @internal
+ *   This API is experimental.
+ */
+final class ContentConfigurator {
+
+  /**
+   * @param array $content
+   *   Content options for a recipe.
+   */
+  public function __construct(public readonly array $content) {
+    // @todo https://www.drupal.org/project/distributions_recipes/issues/3292287
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Recipe/InstallConfigurator.php b/core/lib/Drupal/Core/Recipe/InstallConfigurator.php
new file mode 100644
index 0000000000..2fd2059e5b
--- /dev/null
+++ b/core/lib/Drupal/Core/Recipe/InstallConfigurator.php
@@ -0,0 +1,120 @@
+<?php
+
+namespace Drupal\Core\Recipe;
+
+use Drupal\Component\Assertion\Inspector;
+use Drupal\Core\Extension\Dependency;
+use Drupal\Core\Extension\ModuleExtensionList;
+use Drupal\Core\Extension\ThemeExtensionList;
+
+/**
+ * @internal
+ *   This API is experimental.
+ */
+final class InstallConfigurator {
+
+  /**
+   * The list of modules to install.
+   *
+   * This list is sorted an includes any module dependencies of the provided
+   * extensions.
+   *
+   * @var string[]
+   */
+  public readonly array $modules;
+
+  /**
+   * The list of themes to install.
+   *
+   * This list is sorted an includes any theme dependencies of the provided
+   * extensions.
+   *
+   * @var string[]
+   */
+  public readonly array $themes;
+
+  /**
+   * @param string[] $extensions
+   *   A list of extensions for a recipe to install.
+   * @param \Drupal\Core\Extension\ModuleExtensionList $module_list
+   *   The module list service.
+   * @param \Drupal\Core\Extension\ThemeExtensionList $theme_list
+   *   The theme list service.
+   */
+  public function __construct(array $extensions, ModuleExtensionList $module_list, ThemeExtensionList $theme_list) {
+    assert(Inspector::assertAllStrings($extensions), 'Extension names must be strings.');
+    $extensions = array_map(fn($extension) => Dependency::createFromString($extension)->getName(), $extensions);
+    $extensions = array_combine($extensions, $extensions);
+    $module_data = $module_list->reset()->getList();
+    $theme_data = $theme_list->reset()->getList();
+
+    $modules = array_intersect_key($extensions, $module_data);
+    $themes = array_intersect_key($extensions, $theme_data);
+
+    $missing_extensions = array_diff($extensions, $modules, $themes);
+
+    // Add theme module dependencies.
+    foreach ($themes as $theme => $value) {
+      $modules = array_merge($modules, array_keys($theme_data[$theme]->module_dependencies));
+    }
+
+    // Add modules that other modules depend on.
+    // @todo should recipes do this? I think so. It allows modules to add
+    //   dependencies and recipes continue to work
+    foreach ($modules as $module) {
+      if ($module_data[$module]->requires) {
+        $modules = array_merge($modules, array_keys($module_data[$module]->requires));
+      }
+    }
+
+    // Remove all modules that have been installed already.
+    $modules = array_diff(array_unique($modules), array_keys($module_list->getAllInstalledInfo()));
+    $modules = array_combine($modules, $modules);
+
+    // Create a sortable list of modules.
+    foreach ($modules as $name => $value) {
+      if (isset($module_data[$name])) {
+        $modules[$name] = $module_data[$name]->sort;
+      }
+      else {
+        $missing_extensions[$name] = $name;
+      }
+    }
+
+    // Add any missing base themes to the list of themes to install.
+    foreach ($themes as $theme => $value) {
+      // $theme_data[$theme]->requires contains both theme and module
+      // dependencies keyed by the extension machine names.
+      // $theme_data[$theme]->module_dependencies contains only the module
+      // dependencies keyed by the module extension machine name. Therefore,
+      // we can find the theme dependencies by finding array keys for
+      // 'requires' that are not in $module_dependencies.
+      $theme_dependencies = array_diff_key($theme_data[$theme]->requires, $theme_data[$theme]->module_dependencies);
+      $themes = array_merge($themes, array_keys($theme_dependencies));
+    }
+
+    // Remove all themes that have been installed already.
+    $themes = array_diff(array_unique($themes), array_keys($theme_list->getAllInstalledInfo()));
+    $themes = array_combine($themes, $themes);
+
+    // Create a sortable list of themes.
+    foreach ($themes as $name => $value) {
+      if (isset($theme_data[$name])) {
+        $themes[$name] = $theme_data[$name]->sort;
+      }
+      else {
+        $missing_extensions[$name] = $name;
+      }
+    }
+
+    if (!empty($missing_extensions)) {
+      throw new RecipeMissingExtensionsException(array_values($missing_extensions));
+    }
+
+    arsort($modules);
+    arsort($themes);
+    $this->modules = array_keys($modules);
+    $this->themes = array_keys($themes);
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Recipe/Recipe.php b/core/lib/Drupal/Core/Recipe/Recipe.php
new file mode 100644
index 0000000000..ed35e1887d
--- /dev/null
+++ b/core/lib/Drupal/Core/Recipe/Recipe.php
@@ -0,0 +1,70 @@
+<?php
+
+namespace Drupal\Core\Recipe;
+
+use Drupal\Core\Serialization\Yaml;
+
+/**
+ * @internal
+ *   This API is experimental.
+ */
+final class Recipe {
+
+  const COMPOSER_PROJECT_TYPE = 'drupal-recipe';
+
+  public function __construct(
+    public readonly string $name,
+    public readonly string $description,
+    public readonly string $type,
+    public readonly RecipeConfigurator $recipes,
+    public readonly InstallConfigurator $install,
+    public readonly ConfigConfigurator $config,
+    public readonly ContentConfigurator $content
+  ) {
+  }
+
+  /**
+   * Creates a recipe object from the provided path.
+   *
+   * @param string $path
+   *   The path to a recipe.
+   *
+   * @return static
+   *   The Recipe object.
+   */
+  public static function createFromDirectory(string $path): static {
+    if (!is_readable($path . '/recipe.yml')) {
+      throw new RecipeFileException("There is no $path/recipe.yml file");
+    }
+
+    $recipe_contents = file_get_contents($path . '/recipe.yml');
+    if (!$recipe_contents) {
+      throw new RecipeFileException("$path/recipe.yml cannot be read");
+    }
+    $recipe_data = Yaml::decode($recipe_contents);
+    // @todo Do we need to improve validation?
+    if (!is_array($recipe_data)) {
+      throw new RecipeFileException("$path/recipe.yml is invalid");
+    }
+    $recipe_data += [
+      'description' => '',
+      'type' => '',
+      'recipes' => [],
+      'install' => [],
+      'config' => [],
+      'content' => [],
+    ];
+
+    if (!isset($recipe_data['name'])) {
+      throw new RecipeFileException("The $path/recipe.yml has no name value.");
+    }
+
+    $recipe_discovery = new RecipeDiscovery([dirname($path)]);
+    $recipes = new RecipeConfigurator($recipe_data['recipes'], $recipe_discovery);
+    $install = new InstallConfigurator($recipe_data['install'], \Drupal::service('extension.list.module'), \Drupal::service('extension.list.theme'));
+    $config = new ConfigConfigurator($recipe_data['config'], $path, \Drupal::service('config.storage'));
+    $content = new ContentConfigurator($recipe_data['content']);
+    return new static($recipe_data['name'], $recipe_data['description'], $recipe_data['type'], $recipes, $install, $config, $content);
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Recipe/RecipeCommand.php b/core/lib/Drupal/Core/Recipe/RecipeCommand.php
new file mode 100644
index 0000000000..6b3414aec9
--- /dev/null
+++ b/core/lib/Drupal/Core/Recipe/RecipeCommand.php
@@ -0,0 +1,111 @@
+<?php
+
+namespace Drupal\Core\Recipe;
+
+use Drupal\Core\DrupalKernel;
+use Drupal\Core\Site\Settings;
+use Symfony\Component\Console\Command\Command;
+use Symfony\Component\Console\Input\InputArgument;
+use Symfony\Component\Console\Input\InputInterface;
+use Symfony\Component\Console\Output\OutputInterface;
+use Symfony\Component\Console\Style\SymfonyStyle;
+use Symfony\Component\HttpFoundation\Request;
+
+/**
+ * Applies recipe.
+ *
+ * @internal
+ *   This API is experimental.
+ */
+final class RecipeCommand extends Command {
+
+  /**
+   * The class loader.
+   *
+   * @var object
+   */
+  protected $classLoader;
+
+  /**
+   * Constructs a new ServerCommand command.
+   *
+   * @param object $class_loader
+   *   The class loader.
+   */
+  public function __construct($class_loader) {
+    parent::__construct('recipe');
+    $this->classLoader = $class_loader;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function configure(): void {
+    $this
+      ->setDescription('Applies a recipe to a site.')
+      ->addArgument('path', InputArgument::REQUIRED, 'The path to the recipe\'s folder to apply');
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function execute(InputInterface $input, OutputInterface $output): int {
+    $io = new SymfonyStyle($input, $output);
+
+    if (PHP_VERSION_ID < 80100) {
+      $io->error('Recipes require PHP 8.1');
+      return 1;
+    }
+
+    $recipe_path = $input->getArgument('path');
+    if (!is_string($recipe_path) || !is_dir($recipe_path)) {
+      $io->error(sprintf('The supplied path %s is not a directory', $recipe_path));
+    }
+
+    // Recipes have to be applied to installed sites.
+    $container = $this->boot()->getContainer();
+
+    /** @var \Drupal\Core\Config\Checkpoint\CheckpointStorageInterface $checkpoint_storage */
+    $checkpoint_storage = $container->get('config.storage.checkpoint');
+    $recipe = Recipe::createFromDirectory($recipe_path);
+    $checkpoint_storage->checkpoint("Backup before the '$recipe->name' recipe.");
+    RecipeRunner::processRecipe($recipe);
+
+    $io->success(sprintf('%s applied successfully', $recipe->name));
+    return 0;
+  }
+
+  /**
+   * Boots up a Drupal environment.
+   *
+   * @return \Drupal\Core\DrupalKernelInterface
+   *   The Drupal kernel.
+   *
+   * @throws \Exception
+   *   Exception thrown if kernel does not boot.
+   */
+  protected function boot() {
+    $kernel = new DrupalKernel('prod', $this->classLoader, FALSE);
+    $kernel::bootEnvironment();
+    $kernel->setSitePath($this->getSitePath());
+    Settings::initialize($kernel->getAppRoot(), $kernel->getSitePath(), $this->classLoader);
+    $kernel->boot();
+    $kernel->preHandle(Request::createFromGlobals());
+
+    return $kernel;
+  }
+
+  /**
+   * Gets the site path.
+   *
+   * Defaults to 'sites/default'. For testing purposes this can be overridden
+   * using the DRUPAL_DEV_SITE_PATH environment variable.
+   *
+   * @return string
+   *   The site path to use.
+   */
+  protected function getSitePath() {
+    return getenv('DRUPAL_DEV_SITE_PATH') ?: 'sites/default';
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Recipe/RecipeConfigInstaller.php b/core/lib/Drupal/Core/Recipe/RecipeConfigInstaller.php
new file mode 100644
index 0000000000..70d6308d22
--- /dev/null
+++ b/core/lib/Drupal/Core/Recipe/RecipeConfigInstaller.php
@@ -0,0 +1,63 @@
+<?php
+
+namespace Drupal\Core\Recipe;
+
+use Drupal\Core\Config\ConfigInstaller;
+use Drupal\Core\Config\Entity\ConfigDependencyManager;
+use Drupal\Core\Config\StorageInterface;
+
+/**
+ * Extends the ConfigInstaller service for recipes.
+ *
+ * @internal
+ *   This API is experimental.
+ */
+final class RecipeConfigInstaller extends ConfigInstaller {
+
+  /**
+   * {@inheritdoc}
+   */
+  public function installRecipeConfig(ConfigConfigurator $recipe_config): void {
+    $storage = $recipe_config->getConfigStorage();
+
+    // Build the list of possible configuration to create.
+    $list = $storage->listAll();
+
+    $enabled_extensions = $this->getEnabledExtensions();
+    $existing_config = $this->getActiveStorages()->listAll();
+
+    // Filter the list of configuration to only include configuration that
+    // should be created.
+    $list = array_filter($list, function ($config_name) use ($existing_config) {
+      // Only list configuration that:
+      // - does not already exist
+      return !in_array($config_name, $existing_config);
+    });
+
+    // If there is nothing to do.
+    if (empty($list)) {
+      return;
+    }
+
+    $all_config = array_merge($existing_config, $list);
+    $all_config = array_combine($all_config, $all_config);
+    $config_to_create = $storage->readMultiple($list);
+
+    // Sort $config_to_create in the order of the least dependent first.
+    $dependency_manager = new ConfigDependencyManager();
+    $dependency_manager->setData($config_to_create);
+    $config_to_create = array_merge(array_flip($dependency_manager->sortAll()), $config_to_create);
+
+    foreach ($config_to_create as $config_name => $data) {
+      if (!$this->validateDependencies($config_name, $data, $enabled_extensions, $all_config)) {
+        throw new RecipeUnmetDependenciesException($config_name, sprintf("The configuration '%s' has unmet dependencies", $config_name));
+      }
+    }
+
+    // Create the optional configuration if there is any left after filtering.
+    if (!empty($config_to_create)) {
+      $this->createConfiguration(StorageInterface::DEFAULT_COLLECTION, $config_to_create);
+    }
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Recipe/RecipeConfigStorageWrapper.php b/core/lib/Drupal/Core/Recipe/RecipeConfigStorageWrapper.php
new file mode 100644
index 0000000000..d2808d16dd
--- /dev/null
+++ b/core/lib/Drupal/Core/Recipe/RecipeConfigStorageWrapper.php
@@ -0,0 +1,156 @@
+<?php
+
+namespace Drupal\Core\Recipe;
+
+use Drupal\Core\Config\NullStorage;
+use Drupal\Core\Config\StorageInterface;
+
+/**
+ * Merges two storages together.
+ *
+ * @internal
+ *   This API is experimental.
+ */
+final class RecipeConfigStorageWrapper implements StorageInterface {
+
+  /**
+   * @param \Drupal\Core\Config\StorageInterface $storageA
+   *   First config storage to wrap.
+   * @param \Drupal\Core\Config\StorageInterface $storageB
+   *   Second config storage to wrap.
+   * @param string $collection
+   *   (optional) The collection to store configuration in. Defaults to the
+   *   default collection.
+   */
+  public function __construct(protected readonly StorageInterface $storageA, protected readonly StorageInterface $storageB, protected readonly string $collection = StorageInterface::DEFAULT_COLLECTION) {
+  }
+
+  /**
+   * Creates a single config storage for an array of storages.
+   *
+   * If the same configuration is contained in multiple storages then the
+   * version returned is from the first storage supplied in the $storages array.
+   *
+   * @param \Drupal\Core\Config\StorageInterface[] $storages
+   *   An array of storages to merge into a single storage.
+   *
+   * @return \Drupal\Core\Config\StorageInterface
+   *   A config storage that represents a merge of all the provided storages.
+   */
+  public static function createStorageFromArray(array $storages): StorageInterface {
+    // If storages is empty use the NullStorage to represent an empty storage.
+    if (empty($storages)) {
+      return new NullStorage();
+    }
+
+    // When there is only one storage there is no point wrapping it.
+    if (count($storages) === 1) {
+      return reset($storages);
+    }
+
+    // Reduce all the storages to a single RecipeConfigStorageWrapper object.
+    // The storages are prioritized in the order they are added to $storages.
+    return array_reduce($storages, fn(StorageInterface $carry, StorageInterface $storage) => new static($carry, $storage), new static(
+      array_shift($storages),
+      array_shift($storages)
+    ));
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function exists($name): bool {
+    return $this->storageA->exists($name) || $this->storageB->exists($name);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function read($name): array|bool {
+    return $this->storageA->read($name) ?: $this->storageB->read($name);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function readMultiple(array $names): array {
+    // If both storageA and storageB contain the same configuration, the value
+    // for storageA takes precedence.
+    return array_merge($this->storageB->readMultiple($names), $this->storageA->readMultiple($names));
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function write($name, array $data): bool {
+    throw new \BadMethodCallException();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function delete($name): bool {
+    throw new \BadMethodCallException();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function rename($name, $new_name): bool {
+    throw new \BadMethodCallException();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function encode($data): string {
+    return $this->storageA->encode($data);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function decode($raw): array {
+    return $this->storageA->decode($raw);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function listAll($prefix = ''): array {
+    return array_unique(array_merge($this->storageA->listAll($prefix), $this->storageB->listAll($prefix)));
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function deleteAll($prefix = ''): bool {
+    throw new \BadMethodCallException();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function createCollection($collection): static {
+    return new static(
+      $this->storageA->createCollection($collection),
+      $this->storageB->createCollection($collection),
+      $collection
+    );
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getAllCollectionNames(): array {
+    return array_unique(array_merge($this->storageA->getAllCollectionNames(), $this->storageB->getAllCollectionNames()));
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getCollectionName(): string {
+    return $this->collection;
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Recipe/RecipeConfigurator.php b/core/lib/Drupal/Core/Recipe/RecipeConfigurator.php
new file mode 100644
index 0000000000..f541675e36
--- /dev/null
+++ b/core/lib/Drupal/Core/Recipe/RecipeConfigurator.php
@@ -0,0 +1,24 @@
+<?php
+
+namespace Drupal\Core\Recipe;
+
+/**
+ * @internal
+ *   This API is experimental.
+ */
+final class RecipeConfigurator {
+
+  public readonly array $recipes;
+
+  /**
+   * @param string[] $recipes
+   *   A list of recipes for a recipe to apply. The recipes will be applied in
+   *   the order listed.
+   * @param \Drupal\Core\Recipe\RecipeDiscovery $recipeDiscovery
+   *   Recipe discovery.
+   */
+  public function __construct(array $recipes, RecipeDiscovery $recipeDiscovery) {
+    $this->recipes = array_map([$recipeDiscovery, 'getRecipe'], $recipes);
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Recipe/RecipeDiscovery.php b/core/lib/Drupal/Core/Recipe/RecipeDiscovery.php
new file mode 100644
index 0000000000..02e88a6481
--- /dev/null
+++ b/core/lib/Drupal/Core/Recipe/RecipeDiscovery.php
@@ -0,0 +1,55 @@
+<?php
+
+namespace Drupal\Core\Recipe;
+
+use Drupal\Component\Assertion\Inspector;
+use Drupal\Core\Site\Settings;
+
+/**
+ * @internal
+ *   This API is experimental.
+ */
+final class RecipeDiscovery {
+
+  /**
+   * Constructs a recipe discovery object.
+   *
+   * @param array $paths
+   *   An array of paths where to search for recipes. The path will be searched
+   *   folders containing a recipe.yml. There will be no traversal further into
+   *   the directory structure.
+   */
+  public function __construct(protected readonly array $paths) {
+    assert(Inspector::assertAllStrings($paths), 'Paths must be strings.');
+  }
+
+  /**
+   * Constructs a RecipeDiscovery object.
+   *
+   * @param string $name
+   *   The machine name of the recipe to find.
+   *
+   * @return \Drupal\Core\Recipe\Recipe
+   *   The recipe object.
+   *
+   * @throws \Drupal\Core\Recipe\UnknownRecipeException
+   *   Thrown when the recipe cannot be found.
+   */
+  public function getRecipe(string $name): Recipe {
+    $paths = [
+      ...$this->paths,
+      DRUPAL_ROOT . '/recipes',
+      DRUPAL_ROOT . '/core/recipes',
+    ];
+    if (Settings::get('extension_discovery_scan_tests')) {
+      $paths[] = DRUPAL_ROOT . '/core/tests/fixtures/recipes';
+    }
+    foreach ($paths as $path) {
+      if (file_exists($path . DIRECTORY_SEPARATOR . $name . DIRECTORY_SEPARATOR . 'recipe.yml')) {
+        return Recipe::createFromDirectory($path . DIRECTORY_SEPARATOR . $name);
+      }
+    }
+    throw new UnknownRecipeException($name, $this->paths, sprintf("Can not find the %s recipe, search paths: %s", $name, implode(', ', $this->paths)));
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Recipe/RecipeExtensionConfigStorage.php b/core/lib/Drupal/Core/Recipe/RecipeExtensionConfigStorage.php
new file mode 100644
index 0000000000..4dfaf80d3e
--- /dev/null
+++ b/core/lib/Drupal/Core/Recipe/RecipeExtensionConfigStorage.php
@@ -0,0 +1,144 @@
+<?php
+
+namespace Drupal\Core\Recipe;
+
+use Drupal\Core\Config\FileStorage;
+use Drupal\Core\Config\StorageInterface;
+
+/**
+ * Allows the recipe to select configuration from the module.
+ *
+ * @internal
+ *   This API is experimental.
+ */
+final class RecipeExtensionConfigStorage implements StorageInterface {
+
+  protected readonly StorageInterface $storage;
+
+  /**
+   * @param string $extensionPath
+   *   The path extension to read configuration from
+   * @param array $configNames
+   *   The list of config to read from the extension. An empty array means all
+   *   configuration.
+   * @param string $collection
+   *   (optional) The collection to store configuration in. Defaults to the
+   *   default collection.
+   */
+  public function __construct(protected readonly string $extensionPath, protected readonly array $configNames, protected readonly string $collection = StorageInterface::DEFAULT_COLLECTION) {
+    $this->storage = new RecipeConfigStorageWrapper(
+      new FileStorage($this->extensionPath . '/config/install', $this->collection),
+      new FileStorage($this->extensionPath . '/config/optional', $this->collection),
+      $collection
+    );
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function exists($name): bool {
+    if (!empty($this->configNames) && !in_array($name, $this->configNames, TRUE)) {
+      return FALSE;
+    }
+    return $this->storage->exists($name);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function read($name): array|bool {
+    if (!empty($this->configNames) && !in_array($name, $this->configNames, TRUE)) {
+      return FALSE;
+    }
+    return $this->storage->read($name);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function readMultiple(array $names): array {
+    if (!empty($this->configNames)) {
+      $names = array_intersect($this->configNames, $names);
+    }
+    return $this->storage->readMultiple($names);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function write($name, array $data): bool {
+    throw new \BadMethodCallException();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function delete($name): bool {
+    throw new \BadMethodCallException();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function rename($name, $new_name): bool {
+    throw new \BadMethodCallException();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function encode($data): string {
+    return $this->storage->encode($data);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function decode($raw): array {
+    return $this->storage->decode($raw);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function listAll($prefix = ''): array {
+    $names = $this->storage->listAll($prefix);
+    if (!empty($this->configNames)) {
+      $names = array_intersect($this->configNames, $names);
+    }
+    return $names;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function deleteAll($prefix = ''): bool {
+    throw new \BadMethodCallException();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function createCollection($collection): static {
+    return new static(
+      $this->extensionPath,
+      $this->configNames,
+      $collection
+    );
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getAllCollectionNames(): array {
+    return $this->storage->getAllCollectionNames();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getCollectionName(): string {
+    return $this->collection;
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Recipe/RecipeFileException.php b/core/lib/Drupal/Core/Recipe/RecipeFileException.php
new file mode 100644
index 0000000000..e3f6cffccf
--- /dev/null
+++ b/core/lib/Drupal/Core/Recipe/RecipeFileException.php
@@ -0,0 +1,11 @@
+<?php
+
+namespace Drupal\Core\Recipe;
+
+/**
+ * @internal
+ *   This API is experimental.
+ */
+final class RecipeFileException extends \RuntimeException {
+
+}
diff --git a/core/lib/Drupal/Core/Recipe/RecipeMissingExtensionsException.php b/core/lib/Drupal/Core/Recipe/RecipeMissingExtensionsException.php
new file mode 100644
index 0000000000..ebef022987
--- /dev/null
+++ b/core/lib/Drupal/Core/Recipe/RecipeMissingExtensionsException.php
@@ -0,0 +1,37 @@
+<?php
+
+namespace Drupal\Core\Recipe;
+
+use Drupal\Component\Assertion\Inspector;
+
+/**
+ * Exception thrown when recipes contain or depend on missing extensions.
+ *
+ * @internal
+ *   This API is experimental.
+ */
+final class RecipeMissingExtensionsException extends \RuntimeException {
+
+  /**
+   * Constructs a RecipeMissingExtensionsException.
+   *
+   * @param array $extensions
+   *   The list of missing extensions.
+   * @param string $message
+   *   [optional] The Exception message to throw.
+   * @param int $code
+   *   [optional] The Exception code.
+   * @param null|\Throwable $previous
+   *   [optional] The previous throwable used for the exception chaining.
+   */
+  public function __construct(public readonly array $extensions, string $message = "", int $code = 0, ?\Throwable $previous = NULL) {
+    assert(Inspector::assertAllStrings($extensions), 'Extension names must be strings.');
+    if (!$message) {
+      $sorted = $this->extensions;
+      sort($sorted);
+      $message = sprintf("The following extensions are missing and are required for this recipe: %s", implode(", ", $sorted));
+    }
+    parent::__construct($message, $code, $previous);
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Recipe/RecipeOverrideConfigStorage.php b/core/lib/Drupal/Core/Recipe/RecipeOverrideConfigStorage.php
new file mode 100644
index 0000000000..02cdca54c2
--- /dev/null
+++ b/core/lib/Drupal/Core/Recipe/RecipeOverrideConfigStorage.php
@@ -0,0 +1,131 @@
+<?php
+
+namespace Drupal\Core\Recipe;
+
+use Drupal\Core\Config\StorageInterface;
+
+/**
+ * Wraps a config storage to allow recipe provided configuration to override it.
+ *
+ * @internal
+ *   This API is experimental.
+ */
+final class RecipeOverrideConfigStorage implements StorageInterface {
+
+  /**
+   * @param \Drupal\Core\Config\StorageInterface $recipeStorage
+   *   The recipe's configuration storage.
+   * @param \Drupal\Core\Config\StorageInterface $wrappedStorage
+   *   The storage to override.
+   * @param string $collection
+   *   (optional) The collection to store configuration in. Defaults to the
+   *   default collection.
+   */
+  public function __construct(protected readonly StorageInterface $recipeStorage, protected readonly StorageInterface $wrappedStorage, protected readonly string $collection = StorageInterface::DEFAULT_COLLECTION) {
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function exists($name): bool {
+    return $this->wrappedStorage->exists($name);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function read($name): array|bool {
+    if ($this->wrappedStorage->exists($name) && $this->recipeStorage->exists($name)) {
+      return $this->recipeStorage->read($name);
+    }
+    return $this->wrappedStorage->read($name);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function readMultiple(array $names): array {
+    $data = $this->wrappedStorage->readMultiple($names);
+    foreach ($data as $name => $value) {
+      if ($this->recipeStorage->exists($name)) {
+        $data[$name] = $this->recipeStorage->read($name);
+      }
+    }
+    return $data;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function write($name, array $data): bool {
+    throw new \BadMethodCallException();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function delete($name): bool {
+    throw new \BadMethodCallException();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function rename($name, $new_name): bool {
+    throw new \BadMethodCallException();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function encode($data): string {
+    return $this->wrappedStorage->encode($data);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function decode($raw): array {
+    return $this->wrappedStorage->decode($raw);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function listAll($prefix = ''): array {
+    return $this->wrappedStorage->listAll($prefix);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function deleteAll($prefix = ''): bool {
+    throw new \BadMethodCallException();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function createCollection($collection): static {
+    return new static(
+      $this->recipeStorage->createCollection($collection),
+      $this->wrappedStorage->createCollection($collection),
+      $collection
+    );
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getAllCollectionNames(): array {
+    return $this->wrappedStorage->getAllCollectionNames();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getCollectionName(): string {
+    return $this->collection;
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Recipe/RecipePreExistingConfigException.php b/core/lib/Drupal/Core/Recipe/RecipePreExistingConfigException.php
new file mode 100644
index 0000000000..ce0bd543bc
--- /dev/null
+++ b/core/lib/Drupal/Core/Recipe/RecipePreExistingConfigException.php
@@ -0,0 +1,26 @@
+<?php
+
+namespace Drupal\Core\Recipe;
+
+/**
+ * Exception thrown when a recipe has configuration that exists already.
+ */
+class RecipePreExistingConfigException extends \RuntimeException {
+
+  /**
+   * Constructs a RecipePreExistingConfigException.
+   *
+   * @param string $configName
+   *   The configuration name that has missing dependencies.
+   * @param string $message
+   *   [optional] The Exception message to throw.
+   * @param int $code
+   *   [optional] The Exception code.
+   * @param null|\Throwable $previous
+   *   [optional] The previous throwable used for the exception chaining.
+   */
+  public function __construct(public readonly string $configName, string $message = "", int $code = 0, ?\Throwable $previous = NULL) {
+    parent::__construct($message, $code, $previous);
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Recipe/RecipeRunner.php b/core/lib/Drupal/Core/Recipe/RecipeRunner.php
new file mode 100644
index 0000000000..5670c1f871
--- /dev/null
+++ b/core/lib/Drupal/Core/Recipe/RecipeRunner.php
@@ -0,0 +1,124 @@
+<?php
+
+namespace Drupal\Core\Recipe;
+
+use Drupal\Core\Config\FileStorage;
+use Drupal\Core\Config\InstallStorage;
+use Drupal\Core\Config\StorageInterface;
+
+/**
+ * Applies a recipe.
+ *
+ * This class currently static and use \Drupal::service() in order to put off
+ * having to solve issues caused by container rebuilds during module install and
+ * configuration import.
+ *
+ * @internal
+ *   This API is experimental.
+ */
+final class RecipeRunner {
+
+  /**
+   * @param \Drupal\Core\Recipe\Recipe $recipe
+   *   The recipe to apply.
+   */
+  public static function processRecipe(Recipe $recipe): void {
+    static::processRecipes($recipe->recipes);
+    static::processInstall($recipe->install, $recipe->config->getConfigStorage());
+    static::processConfiguration($recipe->config);
+    static::processContent($recipe->content);
+  }
+
+  /**
+   * Applies any recipes listed by the recipe.
+   *
+   * @param \Drupal\Core\Recipe\RecipeConfigurator $recipes
+   *   The list of recipes to apply.
+   */
+  protected static function processRecipes(RecipeConfigurator $recipes): void {
+    foreach ($recipes->recipes as $recipe) {
+      static::processRecipe($recipe);
+    }
+  }
+
+  /**
+   * Installs the extensions.
+   *
+   * @param \Drupal\Core\Recipe\InstallConfigurator $install
+   *   The list of extensions to install.
+   * @param \Drupal\Core\Config\StorageInterface $recipeConfigStorage
+   *   The recipe's configuration storage. Used to override extension provided
+   *   configuration.
+   */
+  protected static function processInstall(InstallConfigurator $install, StorageInterface $recipeConfigStorage): void {
+    foreach ($install->modules as $name) {
+      // Disable configuration entity install but use the config directory from
+      // the module.
+      \Drupal::service('config.installer')->setSyncing(TRUE);
+      $default_install_path = \Drupal::service('extension.list.module')->get($name)->getPath() . '/' . InstallStorage::CONFIG_INSTALL_DIRECTORY;
+      // Allow the recipe to override simple configuration from the module.
+      $storage = new RecipeOverrideConfigStorage(
+        $recipeConfigStorage,
+        new FileStorage($default_install_path, StorageInterface::DEFAULT_COLLECTION)
+      );
+      \Drupal::service('config.installer')->setSourceStorage($storage);
+
+      \Drupal::service('module_installer')->install([$name]);
+      \Drupal::service('config.installer')->setSyncing(FALSE);
+    }
+
+    // Themes can depend on modules so have to be installed after modules.
+    foreach ($install->themes as $name) {
+      // Disable configuration entity install.
+      \Drupal::service('config.installer')->setSyncing(TRUE);
+      $default_install_path = \Drupal::service('extension.list.theme')->get($name)->getPath() . '/' . InstallStorage::CONFIG_INSTALL_DIRECTORY;
+      // Allow the recipe to override simple configuration from the theme.
+      $storage = new RecipeOverrideConfigStorage(
+        $recipeConfigStorage,
+        new FileStorage($default_install_path, StorageInterface::DEFAULT_COLLECTION)
+      );
+      \Drupal::service('config.installer')->setSourceStorage($storage);
+
+      \Drupal::service('theme_installer')->install([$name]);
+      \Drupal::service('config.installer')->setSyncing(FALSE);
+    }
+  }
+
+  /**
+   * Creates configuration and applies configuration actions.
+   *
+   * @param \Drupal\Core\Recipe\ConfigConfigurator $config
+   *   The config configurator from the recipe.
+   */
+  protected static function processConfiguration(ConfigConfigurator $config): void {
+    // @todo sort out this monstrosity.
+    $config_installer = new RecipeConfigInstaller(
+      \Drupal::service('config.factory'),
+      \Drupal::service('config.storage'),
+      \Drupal::service('config.typed'),
+      \Drupal::service('config.manager'),
+      \Drupal::service('event_dispatcher'),
+      NULL,
+      \Drupal::service('extension.path.resolver'));
+
+    // Create configuration that is either supplied by the recipe or listed in
+    // the config.import section that does not exist.
+    $config_installer->installRecipeConfig($config);
+
+    if (!empty($config->config['actions'])) {
+      // Process the actions.
+      /** @var \Drupal\Core\Config\Action\ConfigActionManager $config_action_manager */
+      $config_action_manager = \Drupal::service('plugin.manager.config_action');
+      foreach ($config->config['actions'] as $config_name => $actions) {
+        foreach ($actions as $action_id => $data) {
+          $config_action_manager->applyAction($action_id, $config_name, $data);
+        }
+      }
+    }
+  }
+
+  protected static function processContent(ContentConfigurator $content): void {
+    // @todo https://www.drupal.org/project/distributions_recipes/issues/3292287
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Recipe/RecipeUnmetDependenciesException.php b/core/lib/Drupal/Core/Recipe/RecipeUnmetDependenciesException.php
new file mode 100644
index 0000000000..71fcdc6b2a
--- /dev/null
+++ b/core/lib/Drupal/Core/Recipe/RecipeUnmetDependenciesException.php
@@ -0,0 +1,29 @@
+<?php
+
+namespace Drupal\Core\Recipe;
+
+/**
+ * Exception thrown when a recipe has configuration with unmet dependencies.
+ *
+ * @internal
+ *   This API is experimental.
+ */
+final class RecipeUnmetDependenciesException extends \RuntimeException {
+
+  /**
+   * Constructs a RecipeUnmetDependenciesException.
+   *
+   * @param string $configName
+   *   The configuration name that has missing dependencies.
+   * @param string $message
+   *   [optional] The Exception message to throw.
+   * @param int $code
+   *   [optional] The Exception code.
+   * @param null|\Throwable $previous
+   *   [optional] The previous throwable used for the exception chaining.
+   */
+  public function __construct(public readonly string $configName, string $message = "", int $code = 0, ?\Throwable $previous = NULL) {
+    parent::__construct($message, $code, $previous);
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Recipe/UnknownRecipeException.php b/core/lib/Drupal/Core/Recipe/UnknownRecipeException.php
new file mode 100644
index 0000000000..9351ba4dc6
--- /dev/null
+++ b/core/lib/Drupal/Core/Recipe/UnknownRecipeException.php
@@ -0,0 +1,29 @@
+<?php
+
+namespace Drupal\Core\Recipe;
+
+/**
+ * Exception thrown when recipe is can not be found.
+ *
+ * @internal
+ *   This API is experimental.
+ */
+final class UnknownRecipeException extends \RuntimeException {
+
+  /**
+   * @param string $recipe
+   *   The recipe's name.
+   * @param array $searchPaths
+   *   The paths searched for the recipe.
+   * @param string $message
+   *   (optional) The exception message.
+   * @param int $code
+   *   (optional) The exception code.
+   * @param \Throwable|null $previous
+   *   (optional) The previous exception.
+   */
+  public function __construct(public readonly string $recipe, public readonly array $searchPaths, string $message = "", int $code = 0, ?\Throwable $previous = NULL) {
+    parent::__construct($message, $code, $previous);
+  }
+
+}
diff --git a/core/modules/config/tests/config_action_duplicate_test/config_action_duplicate_test.info.yml b/core/modules/config/tests/config_action_duplicate_test/config_action_duplicate_test.info.yml
new file mode 100644
index 0000000000..2f1dd51d4c
--- /dev/null
+++ b/core/modules/config/tests/config_action_duplicate_test/config_action_duplicate_test.info.yml
@@ -0,0 +1,4 @@
+name: 'Config action duplicate test'
+type: module
+package: Testing
+version: VERSION
diff --git a/core/modules/config/tests/config_action_duplicate_test/src/Plugin/ConfigAction/DuplicateConfigAction.php b/core/modules/config/tests/config_action_duplicate_test/src/Plugin/ConfigAction/DuplicateConfigAction.php
new file mode 100644
index 0000000000..d19474c620
--- /dev/null
+++ b/core/modules/config/tests/config_action_duplicate_test/src/Plugin/ConfigAction/DuplicateConfigAction.php
@@ -0,0 +1,26 @@
+<?php
+
+namespace Drupal\config_duplicate_action_test\Plugin\ConfigAction;
+
+use Drupal\Core\Config\Action\ConfigActionPluginInterface;
+
+/**
+ * @ConfigAction(
+ *   id = "config_action_duplicate_test:config_test.dynamic:setProtectedProperty",
+ *   admin_label = @Translation("A duplicate config action"),
+ *   entity_types = {
+ *     "config_test"
+ *   }
+ * )
+ */
+final class DuplicateConfigAction implements ConfigActionPluginInterface {
+
+  /**
+   * {@inheritdoc}
+   */
+  public function apply(string $configName, mixed $value): void {
+    // This method should never be called.
+    throw new \BadMethodCallException();
+  }
+
+}
diff --git a/core/modules/config/tests/config_collection_install_test/config_collection_install_test.services.yml b/core/modules/config/tests/config_collection_install_test/config_collection_install_test.services.yml
index 3ee0d2360d..6526996af2 100644
--- a/core/modules/config/tests/config_collection_install_test/config_collection_install_test.services.yml
+++ b/core/modules/config/tests/config_collection_install_test/config_collection_install_test.services.yml
@@ -1,5 +1,5 @@
 services:
-  config_events_test.event_subscriber:
+  config_collection_install_test.event_subscriber:
     class: Drupal\config_collection_install_test\EventSubscriber
     arguments: ['@state']
     tags:
diff --git a/core/modules/config/tests/config_collection_install_test/src/EventSubscriber.php b/core/modules/config/tests/config_collection_install_test/src/EventSubscriber.php
index 7f6a60f237..bc907ce3cd 100644
--- a/core/modules/config/tests/config_collection_install_test/src/EventSubscriber.php
+++ b/core/modules/config/tests/config_collection_install_test/src/EventSubscriber.php
@@ -2,8 +2,8 @@
 
 namespace Drupal\config_collection_install_test;
 
+use Drupal\Core\Config\ConfigCollectionEvents;
 use Drupal\Core\Config\ConfigCollectionInfo;
-use Drupal\Core\Config\ConfigEvents;
 use Drupal\Core\State\StateInterface;
 use Symfony\Component\EventDispatcher\EventSubscriberInterface;
 
@@ -27,7 +27,7 @@ public function __construct(StateInterface $state) {
   }
 
   /**
-   * Reacts to the ConfigEvents::COLLECTION_INFO event.
+   * Reacts to the ConfigCollectionEvents::COLLECTION_INFO event.
    *
    * @param \Drupal\Core\Config\ConfigCollectionInfo $collection_info
    *   The configuration collection info event.
@@ -43,7 +43,7 @@ public function addCollections(ConfigCollectionInfo $collection_info) {
    * {@inheritdoc}
    */
   public static function getSubscribedEvents(): array {
-    $events[ConfigEvents::COLLECTION_INFO][] = ['addCollections'];
+    $events[ConfigCollectionEvents::COLLECTION_INFO][] = ['addCollections'];
     return $events;
   }
 
diff --git a/core/modules/config/tests/config_events_test/src/EventSubscriber.php b/core/modules/config/tests/config_events_test/src/EventSubscriber.php
index 8a79b8b606..bca146547b 100644
--- a/core/modules/config/tests/config_events_test/src/EventSubscriber.php
+++ b/core/modules/config/tests/config_events_test/src/EventSubscriber.php
@@ -2,6 +2,7 @@
 
 namespace Drupal\config_events_test;
 
+use Drupal\Core\Config\ConfigCollectionEvents;
 use Drupal\Core\Config\ConfigCrudEvent;
 use Drupal\Core\Config\ConfigEvents;
 use Drupal\Core\State\StateInterface;
@@ -31,17 +32,24 @@ public function __construct(StateInterface $state) {
    *
    * @param \Drupal\Core\Config\ConfigCrudEvent $event
    *   The configuration event.
-   * @param string $name
+   * @param string $event_name
    *   The event name.
    */
-  public function configEventRecorder(ConfigCrudEvent $event, $name) {
+  public function configEventRecorder(ConfigCrudEvent $event, $event_name) {
     $config = $event->getConfig();
-    $this->state->set('config_events_test.event', [
-      'event_name' => $name,
+    $event_info = [
+      'event_name' => $event_name,
       'current_config_data' => $config->get(),
       'original_config_data' => $config->getOriginal(),
       'raw_config_data' => $config->getRawData(),
-    ]);
+    ];
+    $this->state->set('config_events_test.event', $event_info);
+
+    // Record all events that occur.
+    $all_events = $this->state->get('config_events_test.all_events', []);
+    $config_name = $config->getName();
+    $all_events[$event_name][$config_name][] = $event_info;
+    $this->state->set('config_events_test.all_events', $all_events);
   }
 
   /**
@@ -51,6 +59,9 @@ public static function getSubscribedEvents(): array {
     $events[ConfigEvents::SAVE][] = ['configEventRecorder'];
     $events[ConfigEvents::DELETE][] = ['configEventRecorder'];
     $events[ConfigEvents::RENAME][] = ['configEventRecorder'];
+    $events[ConfigCollectionEvents::SAVE_IN_COLLECTION][] = ['configEventRecorder'];
+    $events[ConfigCollectionEvents::DELETE_IN_COLLECTION][] = ['configEventRecorder'];
+    $events[ConfigCollectionEvents::RENAME_IN_COLLECTION][] = ['configEventRecorder'];
     return $events;
   }
 
diff --git a/core/modules/config/tests/config_test/config/schema/config_test.schema.yml b/core/modules/config/tests/config_test/config/schema/config_test.schema.yml
index 2a707facb0..b6b59ec5e3 100644
--- a/core/modules/config/tests/config_test/config/schema/config_test.schema.yml
+++ b/core/modules/config/tests/config_test/config/schema/config_test.schema.yml
@@ -24,6 +24,9 @@ config_test_dynamic:
     protected_property:
       type: string
       label: 'Protected property'
+    array_property:
+      type: ignore
+      label: 'Array property'
 
 config_test.dynamic.*:
   type: config_test_dynamic
diff --git a/core/modules/config/tests/config_test/config_test.module b/core/modules/config/tests/config_test/config_test.module
index ac06237e35..2464708891 100644
--- a/core/modules/config/tests/config_test/config_test.module
+++ b/core/modules/config/tests/config_test/config_test.module
@@ -40,4 +40,8 @@ function config_test_entity_type_alter(array &$entity_types) {
   if (\Drupal::service('state')->get('config_test.lookup_keys', FALSE)) {
     $entity_types['config_test']->set('lookup_keys', ['uuid', 'style']);
   }
+
+  if (\Drupal::service('state')->get('config_test.class_override', FALSE)) {
+    $entity_types['config_test']->setClass(\Drupal::service('state')->get('config_test.class_override'));
+  }
 }
diff --git a/core/modules/config/tests/config_test/src/ConfigActionErrorEntity/DuplicatePluralizedMethodName.php b/core/modules/config/tests/config_test/src/ConfigActionErrorEntity/DuplicatePluralizedMethodName.php
new file mode 100644
index 0000000000..b51e41af5d
--- /dev/null
+++ b/core/modules/config/tests/config_test/src/ConfigActionErrorEntity/DuplicatePluralizedMethodName.php
@@ -0,0 +1,17 @@
+<?php
+
+namespace Drupal\config_test\ConfigActionErrorEntity;
+
+use Drupal\config_test\Entity\ConfigTest;
+use Drupal\Core\Config\Action\Attribute\ActionMethod;
+
+/**
+ * Test entity class.
+ */
+class DuplicatePluralizedMethodName extends ConfigTest {
+
+  #[ActionMethod(pluralize: 'testMethod')]
+  public function testMethod() {
+  }
+
+}
diff --git a/core/modules/config/tests/config_test/src/ConfigActionErrorEntity/DuplicatePluralizedOtherMethodName.php b/core/modules/config/tests/config_test/src/ConfigActionErrorEntity/DuplicatePluralizedOtherMethodName.php
new file mode 100644
index 0000000000..98c5d07559
--- /dev/null
+++ b/core/modules/config/tests/config_test/src/ConfigActionErrorEntity/DuplicatePluralizedOtherMethodName.php
@@ -0,0 +1,21 @@
+<?php
+
+namespace Drupal\config_test\ConfigActionErrorEntity;
+
+use Drupal\config_test\Entity\ConfigTest;
+use Drupal\Core\Config\Action\Attribute\ActionMethod;
+
+/**
+ * Test entity class.
+ */
+class DuplicatePluralizedOtherMethodName extends ConfigTest {
+
+  #[ActionMethod(pluralize: 'testMethod2')]
+  public function testMethod() {
+  }
+
+  #[ActionMethod()]
+  public function testMethod2() {
+  }
+
+}
diff --git a/core/modules/config/tests/config_test/src/Entity/ConfigQueryTest.php b/core/modules/config/tests/config_test/src/Entity/ConfigQueryTest.php
index 6b9e8007db..b461828a63 100644
--- a/core/modules/config/tests/config_test/src/Entity/ConfigQueryTest.php
+++ b/core/modules/config/tests/config_test/src/Entity/ConfigQueryTest.php
@@ -46,4 +46,13 @@ class ConfigQueryTest extends ConfigTest {
    */
   public $array = [];
 
+  /**
+   * {@inheritdoc}
+   */
+  public function concatProtectedProperty(string $value1, string $value2): static {
+    // This method intentionally does not have the config action attribute to
+    // ensure it is still discovered.
+    return parent::concatProtectedProperty($value1, $value2);
+  }
+
 }
diff --git a/core/modules/config/tests/config_test/src/Entity/ConfigTest.php b/core/modules/config/tests/config_test/src/Entity/ConfigTest.php
index 30a7a3526d..0ff6bdd5a8 100644
--- a/core/modules/config/tests/config_test/src/Entity/ConfigTest.php
+++ b/core/modules/config/tests/config_test/src/Entity/ConfigTest.php
@@ -2,10 +2,12 @@
 
 namespace Drupal\config_test\Entity;
 
+use Drupal\Core\Config\Action\Attribute\ActionMethod;
 use Drupal\Core\Config\Entity\ConfigEntityBase;
 use Drupal\config_test\ConfigTestInterface;
 use Drupal\Core\Config\Entity\ConfigEntityInterface;
 use Drupal\Core\Entity\EntityStorageInterface;
+use Drupal\Core\StringTranslation\TranslatableMarkup;
 
 /**
  * Defines the ConfigTest configuration entity.
@@ -36,6 +38,7 @@
  *     "size",
  *     "size_value",
  *     "protected_property",
+ *     "array_property",
  *   },
  *   links = {
  *     "edit-form" = "/admin/structure/config_test/manage/{config_test}",
@@ -83,6 +86,13 @@ class ConfigTest extends ConfigEntityBase implements ConfigTestInterface {
    */
   protected $protected_property;
 
+  /**
+   * An array property of the configuration entity.
+   *
+   * @var array
+   */
+  protected array $array_property = [];
+
   /**
    * {@inheritdoc}
    */
@@ -188,4 +198,130 @@ public function isInstallable() {
     return $this->id != 'isinstallable' || \Drupal::state()->get('config_test.isinstallable');
   }
 
+  /**
+   * Sets the protected property value.
+   *
+   * @param $value
+   *   The value to set.
+   *
+   * @return $this
+   *   The config entity.
+   */
+  #[ActionMethod(pluralize: FALSE)]
+  public function setProtectedProperty(string $value): static {
+    $this->protected_property = $value;
+    return $this;
+  }
+
+  /**
+   * Gets the protected property value.
+   *
+   * @return string
+   *   The protected property value.
+   */
+  public function getProtectedProperty(): string {
+    return $this->protected_property;
+  }
+
+  /**
+   * Concatenates the two params and sets the protected property value.
+   *
+   * @param $value1
+   *   The first value to concatenate.
+   * @param $value2
+   *   The second value to concatenate.
+   *
+   * @return $this
+   *   The config entity.
+   */
+  #[ActionMethod()]
+  public function concatProtectedProperty(string $value1, string $value2): static {
+    $this->protected_property = $value1 . $value2;
+    return $this;
+  }
+
+  /**
+   * Concatenates up to two params and sets the protected property value.
+   *
+   * @param $value1
+   *   The first value to concatenate.
+   * @param $value2
+   *   (optional) The second value to concatenate. Defaults to ''.
+   *
+   * @return $this
+   *   The config entity.
+   */
+  #[ActionMethod(pluralize: FALSE)]
+  public function concatProtectedPropertyOptional(string $value1, string $value2 = ''): static {
+    $this->protected_property = $value1 . $value2;
+    return $this;
+  }
+
+  /**
+   * Appends to protected property.
+   *
+   * @param $value
+   *   The value to append.
+   *
+   * @return $this
+   *   The config entity.
+   */
+  #[ActionMethod()]
+  public function append(string $value): static {
+    $this->protected_property .= $value;
+    return $this;
+  }
+
+  /**
+   * Sets the protected property to a default value.
+   *
+   * @return $this
+   *   The config entity.
+   */
+  #[ActionMethod(pluralize: FALSE, adminLabel: new TranslatableMarkup('Set default name'))]
+  public function defaultProtectedProperty(): static {
+    $this->protected_property = 'Set by method';
+    return $this;
+  }
+
+  /**
+   * Adds a value to the array property.
+   *
+   * @param mixed $value
+   *   The value to add.
+   *
+   * @return $this
+   *   The config entity.
+   */
+  #[ActionMethod(pluralize: 'addToArrayMultipleTimes')]
+  public function addToArray(mixed $value): static {
+    $this->array_property[] = $value;
+    return $this;
+  }
+
+  /**
+   * Gets the array property value.
+   *
+   * @return array
+   *   The array property value.
+   */
+  public function getArrayProperty(): array {
+    return $this->array_property;
+  }
+
+  /**
+   * Sets the array property.
+   *
+   * @param $value
+   *   The value to set.
+   *
+   * @return $this
+   *   The config entity.
+   */
+  #[ActionMethod(pluralize: FALSE)]
+  public function setArray(array $value): static {
+    $this->array_property = $value;
+    return $this;
+  }
+
 }
diff --git a/core/modules/filter/src/Entity/FilterFormat.php b/core/modules/filter/src/Entity/FilterFormat.php
index b47ed360cd..17da5a274f 100644
--- a/core/modules/filter/src/Entity/FilterFormat.php
+++ b/core/modules/filter/src/Entity/FilterFormat.php
@@ -3,9 +3,11 @@
 namespace Drupal\filter\Entity;
 
 use Drupal\Component\Plugin\PluginInspectionInterface;
+use Drupal\Core\Config\Action\Attribute\ActionMethod;
 use Drupal\Core\Config\Entity\ConfigEntityBase;
 use Drupal\Core\Entity\EntityWithPluginCollectionInterface;
 use Drupal\Core\Entity\EntityStorageInterface;
+use Drupal\Core\StringTranslation\TranslatableMarkup;
 use Drupal\filter\FilterFormatInterface;
 use Drupal\filter\FilterPluginCollection;
 use Drupal\filter\Plugin\FilterInterface;
@@ -160,6 +162,7 @@ public function getPluginCollections() {
   /**
    * {@inheritdoc}
    */
+  #[ActionMethod(adminLabel: new TranslatableMarkup('Sets configuration for a filter plugin'))]
   public function setFilterConfig($instance_id, array $configuration) {
     $this->filters[$instance_id] = $configuration;
     if (isset($this->filterCollection)) {
diff --git a/core/modules/language/src/Config/LanguageConfigOverride.php b/core/modules/language/src/Config/LanguageConfigOverride.php
index 3b3b4da3c6..e55425d233 100644
--- a/core/modules/language/src/Config/LanguageConfigOverride.php
+++ b/core/modules/language/src/Config/LanguageConfigOverride.php
@@ -3,6 +3,8 @@
 namespace Drupal\language\Config;
 
 use Drupal\Core\Cache\Cache;
+use Drupal\Core\Config\ConfigCollectionEvents;
+use Drupal\Core\Config\ConfigCrudEvent;
 use Drupal\Core\Config\StorableConfigBase;
 use Drupal\Core\Config\StorageInterface;
 use Drupal\Core\Config\TypedConfigManagerInterface;
@@ -62,6 +64,11 @@ public function save($has_trusted_data = FALSE) {
     // an update of configuration, but only for a specific language.
     Cache::invalidateTags($this->getCacheTags());
     $this->isNew = FALSE;
+    // Dispatch configuration override event as detailed in
+    // \Drupal\Core\Config\ConfigFactoryOverrideInterface::createConfigObject().
+    $this->eventDispatcher->dispatch(new ConfigCrudEvent($this), ConfigCollectionEvents::SAVE_IN_COLLECTION);
+    // Dispatch an event specifically for language configuration override
+    // changes.
     $this->eventDispatcher->dispatch(new LanguageConfigOverrideCrudEvent($this), LanguageConfigOverrideEvents::SAVE_OVERRIDE);
     $this->originalData = $this->data;
     return $this;
@@ -75,6 +82,11 @@ public function delete() {
     $this->storage->delete($this->name);
     Cache::invalidateTags($this->getCacheTags());
     $this->isNew = TRUE;
+    // Dispatch configuration override event as detailed in
+    // \Drupal\Core\Config\ConfigFactoryOverrideInterface::createConfigObject().
+    $this->eventDispatcher->dispatch(new ConfigCrudEvent($this), ConfigCollectionEvents::DELETE_IN_COLLECTION);
+    // Dispatch an event specifically for language configuration override
+    // changes.
     $this->eventDispatcher->dispatch(new LanguageConfigOverrideCrudEvent($this), LanguageConfigOverrideEvents::DELETE_OVERRIDE);
     $this->originalData = $this->data;
     return $this;
diff --git a/core/modules/language/tests/language_events_test/config/schema/config_events_test.schema.yml b/core/modules/language/tests/language_events_test/config/schema/config_events_test.schema.yml
new file mode 100644
index 0000000000..2153cc24fa
--- /dev/null
+++ b/core/modules/language/tests/language_events_test/config/schema/config_events_test.schema.yml
@@ -0,0 +1,7 @@
+config_events_test.test:
+  type: config_object
+  label: 'Configuration events test'
+  mapping:
+    key:
+      type: string
+      label: 'Value'
diff --git a/core/modules/language/tests/language_events_test/language_events_test.info.yml b/core/modules/language/tests/language_events_test/language_events_test.info.yml
new file mode 100644
index 0000000000..0bf0bd633e
--- /dev/null
+++ b/core/modules/language/tests/language_events_test/language_events_test.info.yml
@@ -0,0 +1,4 @@
+name: 'Language events test'
+type: module
+package: Testing
+version: VERSION
diff --git a/core/modules/language/tests/language_events_test/language_events_test.services.yml b/core/modules/language/tests/language_events_test/language_events_test.services.yml
new file mode 100644
index 0000000000..5bba4650ee
--- /dev/null
+++ b/core/modules/language/tests/language_events_test/language_events_test.services.yml
@@ -0,0 +1,6 @@
+services:
+  language_events_test.event_subscriber:
+    class: Drupal\language_events_test\EventSubscriber
+    arguments: ['@state']
+    tags:
+      - { name: event_subscriber }
diff --git a/core/modules/language/tests/language_events_test/src/EventSubscriber.php b/core/modules/language/tests/language_events_test/src/EventSubscriber.php
new file mode 100644
index 0000000000..e805b9fc62
--- /dev/null
+++ b/core/modules/language/tests/language_events_test/src/EventSubscriber.php
@@ -0,0 +1,56 @@
+<?php
+
+namespace Drupal\language_events_test;
+
+use Drupal\Core\State\StateInterface;
+use Drupal\language\Config\LanguageConfigOverrideEvents;
+use Drupal\language\Config\LanguageConfigOverrideCrudEvent;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+
+class EventSubscriber implements EventSubscriberInterface {
+
+  /**
+   * Constructs the Event Subscriber object.
+   *
+   * @param \Drupal\Core\State\StateInterface $state
+   *   The state key value store.
+   */
+  public function __construct(private StateInterface $state) {
+  }
+
+  /**
+   * Reacts to config event.
+   *
+   * @param \Drupal\language\Config\LanguageConfigOverrideCrudEvent $event
+   *   The language configuration event.
+   * @param string $event_name
+   *   The event name.
+   */
+  public function configEventRecorder(LanguageConfigOverrideCrudEvent $event, string $event_name): void {
+    $override = $event->getLanguageConfigOverride();
+    $event_info = [
+      'event_name' => $event_name,
+      'current_override_data' => $override->get(),
+      'original_override_data' => $override->getOriginal(),
+    ];
+
+    // Record all events that occur.
+    $all_events = $this->state->get('language_events_test.all_events', []);
+    $override_name = $override->getName();
+    if (!isset($all_events[$event_name][$override_name])) {
+      $all_events[$event_name][$override_name] = [];
+    }
+    $all_events[$event_name][$override_name][] = $event_info;
+    $this->state->set('language_events_test.all_events', $all_events);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function getSubscribedEvents(): array {
+    $events[LanguageConfigOverrideEvents::SAVE_OVERRIDE][] = ['configEventRecorder'];
+    $events[LanguageConfigOverrideEvents::DELETE_OVERRIDE][] = ['configEventRecorder'];
+    return $events;
+  }
+
+}
diff --git a/core/modules/language/tests/src/Functional/LanguageConfigOverrideImportTest.php b/core/modules/language/tests/src/Functional/LanguageConfigOverrideImportTest.php
index 2600627b3a..5657cf7eb3 100644
--- a/core/modules/language/tests/src/Functional/LanguageConfigOverrideImportTest.php
+++ b/core/modules/language/tests/src/Functional/LanguageConfigOverrideImportTest.php
@@ -2,6 +2,7 @@
 
 namespace Drupal\Tests\language\Functional;
 
+use Drupal\Core\Config\ConfigCollectionEvents;
 use Drupal\language\Entity\ConfigurableLanguage;
 use Drupal\Tests\BrowserTestBase;
 
@@ -91,7 +92,12 @@ public function testConfigOverrideImportEvents() {
     // Test that no config save event has been fired during the import because
     // language configuration overrides do not fire events.
     $event_recorder = \Drupal::state()->get('config_events_test.event', FALSE);
-    $this->assertFalse($event_recorder);
+    $this->assertSame([
+      'event_name' => ConfigCollectionEvents::SAVE_IN_COLLECTION,
+      'current_config_data' => ['name' => 'FR default site name'],
+      'original_config_data' => [],
+      'raw_config_data' => ['name' => 'FR default site name'],
+    ], $event_recorder);
 
     $this->drupalGet('fr');
     $this->assertSession()->pageTextContains('FR default site name');
diff --git a/core/modules/language/tests/src/Kernel/LanguageConfigOverrideInstallTest.php b/core/modules/language/tests/src/Kernel/LanguageConfigOverrideInstallTest.php
index 1883e93133..20d83179ca 100644
--- a/core/modules/language/tests/src/Kernel/LanguageConfigOverrideInstallTest.php
+++ b/core/modules/language/tests/src/Kernel/LanguageConfigOverrideInstallTest.php
@@ -2,6 +2,8 @@
 
 namespace Drupal\Tests\language\Kernel;
 
+use Drupal\Core\Config\ConfigCollectionEvents;
+use Drupal\language\Config\LanguageConfigOverrideEvents;
 use Drupal\language\Entity\ConfigurableLanguage;
 use Drupal\KernelTests\KernelTestBase;
 
@@ -17,22 +19,71 @@ class LanguageConfigOverrideInstallTest extends KernelTestBase {
    *
    * @var array
    */
-  protected static $modules = ['language', 'config_events_test'];
+  protected static $modules = ['language', 'config_events_test', 'language_events_test'];
 
   /**
    * Tests the configuration events are not fired during install of overrides.
    */
   public function testLanguageConfigOverrideInstall() {
+    $this->installConfig(['language']);
     ConfigurableLanguage::createFromLangcode('de')->save();
     // Need to enable test module after creating the language otherwise saving
     // the language will install the configuration.
     $this->enableModules(['language_config_override_test']);
     \Drupal::state()->set('config_events_test.event', FALSE);
+    \Drupal::state()->set('language_events_test.all_events', []);
     $this->installConfig(['language_config_override_test']);
+
+    // Ensure the save-in-collection event is triggered when saving data in
+    // config collections during an install.
     $event_recorder = \Drupal::state()->get('config_events_test.event', FALSE);
-    $this->assertFalse($event_recorder);
+    $this->assertSame([
+      'event_name' => ConfigCollectionEvents::SAVE_IN_COLLECTION,
+      'current_config_data' => ['name' => 'Deutsch'],
+      'original_config_data' => [],
+      'raw_config_data' => ['name' => 'Deutsch'],
+    ], $event_recorder);
     $config = \Drupal::service('language.config_factory_override')->getOverride('de', 'language_config_override_test.settings');
     $this->assertEquals('Deutsch', $config->get('name'));
+
+    // Ensure the save override event is triggered when saving overrides during
+    // an install.
+    $event_recorder = \Drupal::state()->get('language_events_test.all_events', []);
+    $this->assertArrayHasKey(LanguageConfigOverrideEvents::SAVE_OVERRIDE, $event_recorder);
+    $this->assertArrayHasKey('language_config_override_test.settings', $event_recorder[LanguageConfigOverrideEvents::SAVE_OVERRIDE]);
+    $this->assertSame([
+      'event_name' => LanguageConfigOverrideEvents::SAVE_OVERRIDE,
+      'current_override_data' => ['name' => 'Deutsch'],
+      'original_override_data' => [],
+    ], $event_recorder['language.save_override']['language_config_override_test.settings'][0]);
+
+    // Test events during uninstall.
+    \Drupal::state()->set('config_events_test.all_events', []);
+    \Drupal::state()->set('language_events_test.all_events', []);
+    $this->container->get('module_installer')->uninstall(['language_config_override_test']);
+
+    // Ensure the delete-in-collection event is triggered when deleting data in
+    // config collections during an uninstall.
+    $event_recorder = \Drupal::state()->get('config_events_test.all_events', []);
+    $this->assertArrayHasKey(ConfigCollectionEvents::DELETE_IN_COLLECTION, $event_recorder);
+    $this->assertArrayHasKey('language_config_override_test.settings', $event_recorder[ConfigCollectionEvents::DELETE_IN_COLLECTION]);
+    $this->assertSame([
+      'event_name' => ConfigCollectionEvents::DELETE_IN_COLLECTION,
+      'current_config_data' => [],
+      'original_config_data' => ['name' => 'Deutsch'],
+      'raw_config_data' => [],
+    ], $event_recorder[ConfigCollectionEvents::DELETE_IN_COLLECTION]['language_config_override_test.settings'][0]);
+
+    // Ensure the delete override event is triggered when deleting overrides
+    // during an uninstall.
+    $event_recorder = \Drupal::state()->get('language_events_test.all_events', []);
+    $this->assertArrayHasKey(LanguageConfigOverrideEvents::DELETE_OVERRIDE, $event_recorder);
+    $this->assertArrayHasKey('language_config_override_test.settings', $event_recorder[LanguageConfigOverrideEvents::DELETE_OVERRIDE]);
+    $this->assertSame([
+      'event_name' => LanguageConfigOverrideEvents::DELETE_OVERRIDE,
+      'current_override_data' => [],
+      'original_override_data' => ['name' => 'Deutsch'],
+    ], $event_recorder['language.delete_override']['language_config_override_test.settings'][0]);
   }
 
 }
diff --git a/core/modules/user/src/Entity/Role.php b/core/modules/user/src/Entity/Role.php
index 18194f3390..68ddd501f5 100644
--- a/core/modules/user/src/Entity/Role.php
+++ b/core/modules/user/src/Entity/Role.php
@@ -2,8 +2,10 @@
 
 namespace Drupal\user\Entity;
 
+use Drupal\Core\Config\Action\Attribute\ActionMethod;
 use Drupal\Core\Config\Entity\ConfigEntityBase;
 use Drupal\Core\Entity\EntityStorageInterface;
+use Drupal\Core\StringTranslation\TranslatableMarkup;
 use Drupal\user\RoleInterface;
 
 /**
@@ -126,6 +128,7 @@ public function hasPermission($permission) {
   /**
    * {@inheritdoc}
    */
+  #[ActionMethod(adminLabel: new TranslatableMarkup('Add permission to role'))]
   public function grantPermission($permission) {
     if ($this->isAdmin()) {
       return $this;
diff --git a/core/recipes/example/composer.json b/core/recipes/example/composer.json
new file mode 100644
index 0000000000..1d231ba7ee
--- /dev/null
+++ b/core/recipes/example/composer.json
@@ -0,0 +1,9 @@
+{
+  "name": "drupal_recipe/example",
+  "description": "An example Drupal recipe description",
+  "type": "drupal-recipe",
+  "require": {
+    "drupal/core": "^10.0.x-dev"
+  },
+  "license": "GPL-2.0-or-later"
+}
diff --git a/core/recipes/example/recipe.yml b/core/recipes/example/recipe.yml
new file mode 100644
index 0000000000..2103651c07
--- /dev/null
+++ b/core/recipes/example/recipe.yml
@@ -0,0 +1,46 @@
+# The type key is similar to the package key in module.info.yml. It
+# can be used by the UI to group Drupal recipes. Additionally,
+# the type 'Site' means that the Drupal recipe will be listed in
+# the installer.
+type: 'Content type'
+
+install:
+  # An array of modules or themes to install, if they are not already.
+  # The system will detect if it is a theme or a module. During the
+  # install only simple configuration from the new modules is created.
+  # This allows the Drupal recipe control over the configuration.
+  - node
+  - text
+
+config:
+  # A Drupal recipe can have a config directory. All configuration
+  # is this directory will be imported after the modules have been
+  # installed.
+
+  # Additionally, the Drupal recipe can install configuration entities
+  # provided by the modules it configures. This allows them to not have
+  # to maintain or copy this configuration. Note the examples below are
+  # fictitious.
+  import:
+    node:
+      - node.type.article
+    # Import all configuration that is provided by the text module and any
+    # optional configuration that depends on the text module that is provided by
+    # modules already installed.
+    text: *
+
+  # Configuration actions may be defined. The structure here should be
+  # entity_type.ID.action. Below the user role entity type with an ID of
+  # editor is having the permissions added. The permissions key will be
+  # mapped to the \Drupal\user\Entity\Role::grantPermission() method.
+  actions:
+    user.role.editor:
+      ensure_exists:
+        label: 'Editor'
+      grantPermissions:
+        - 'delete any article content'
+        - 'edit any article content'
+
+content:
+# A Drupal recipe can have a content directory. All content in this
+# directory will be created after the configuration is installed.
diff --git a/core/scripts/drupal b/core/scripts/drupal
index 891d5b8117..0c9eb300cd 100644
--- a/core/scripts/drupal
+++ b/core/scripts/drupal
@@ -10,6 +10,7 @@ use Drupal\Core\Command\GenerateTheme;
 use Drupal\Core\Command\QuickStartCommand;
 use Drupal\Core\Command\InstallCommand;
 use Drupal\Core\Command\ServerCommand;
+use Drupal\Core\Recipe\RecipeCommand;
 use Symfony\Component\Console\Application;
 
 if (PHP_SAPI !== 'cli') {
@@ -24,5 +25,6 @@ $application->add(new QuickStartCommand());
 $application->add(new InstallCommand($classloader));
 $application->add(new ServerCommand($classloader));
 $application->add(new GenerateTheme());
+$application->add(new RecipeCommand($classloader));
 
 $application->run();
diff --git a/core/tests/Drupal/FunctionalTests/Core/Recipe/RecipeCommandTest.php b/core/tests/Drupal/FunctionalTests/Core/Recipe/RecipeCommandTest.php
new file mode 100644
index 0000000000..1a3559910a
--- /dev/null
+++ b/core/tests/Drupal/FunctionalTests/Core/Recipe/RecipeCommandTest.php
@@ -0,0 +1,103 @@
+<?php
+
+namespace Drupal\FunctionalTests\Core\Recipe;
+
+use Drupal\Core\Config\Checkpoint\Checkpoint;
+use Drupal\node\Entity\NodeType;
+use Drupal\Tests\BrowserTestBase;
+use Symfony\Component\Process\PhpExecutableFinder;
+use Symfony\Component\Process\Process;
+
+/**
+ * @coversDefaultClass \Drupal\Core\Recipe\RecipeCommand
+ * @group Recipe
+ *
+ * BrowserTestBase is used for a proper Drupal install.
+ */
+class RecipeCommandTest extends BrowserTestBase {
+
+  /**
+   * {@inheritdoc}
+   */
+  protected $defaultTheme = 'stark';
+
+  public function testRecipeCommand(): void {
+    $this->assertFalse(\Drupal::moduleHandler()->moduleExists('node'), 'The node module is not installed');
+    $this->assertCheckpointsExist([]);
+
+    $process = $this->runRecipeCommand('core/tests/fixtures/recipes/install_node_with_config');
+    $this->assertSame(0, $process->getExitCode());
+    $this->assertSame('', $process->getErrorOutput());
+    $this->assertStringContainsString('Install node with config applied successfully', $process->getOutput());
+    $this->assertTrue(\Drupal::moduleHandler()->moduleExists('node'), 'The node module is installed');
+    $this->assertCheckpointsExist(["Backup before the 'Install node with config' recipe."]);
+
+    // Ensure recipes can be applied without affecting pre-existing checkpoints.
+    $process = $this->runRecipeCommand('core/tests/fixtures/recipes/install_two_modules');
+    $this->assertSame(0, $process->getExitCode());
+    $this->assertSame('', $process->getErrorOutput());
+    $this->assertStringContainsString('Install two modules applied successfully', $process->getOutput());
+    $this->assertTrue(\Drupal::moduleHandler()->moduleExists('node'), 'The node module is installed');
+    $this->assertCheckpointsExist([
+      "Backup before the 'Install node with config' recipe.",
+      "Backup before the 'Install two modules' recipe.",
+    ]);
+
+    // Ensure recipes that fail have an exception message.
+    NodeType::load('test')?->delete();
+    $process = $this->runRecipeCommand('core/tests/fixtures/recipes/unmet_config_dependencies');
+    $this->assertSame(1, $process->getExitCode());
+    $this->assertStringContainsString("The configuration 'node.type.test' has unmet dependencies", $process->getErrorOutput());
+    $this->assertCheckpointsExist([
+      "Backup before the 'Install node with config' recipe.",
+      "Backup before the 'Install two modules' recipe.",
+      "Backup before the 'Unmet config dependencies' recipe.",
+    ]);
+  }
+
+  /**
+   * Asserts that the current set of checkpoints matches the given labels.
+   *
+   * @param string[] $expected_labels
+   *   The labels of every checkpoint that is expected to exist currently, in
+   *   the expected order.
+   */
+  private function assertCheckpointsExist(array $expected_labels): void {
+    $checkpoints = \Drupal::service('config.checkpoints');
+    $labels = array_map(fn (Checkpoint $c) => $c->label, iterator_to_array($checkpoints));
+    $this->assertSame($expected_labels, array_values($labels));
+  }
+
+  /**
+   * Runs the `drupal recipe` command.
+   *
+   * @param string ...$arguments
+   *   Additional arguments to pass to the command.
+   *
+   * @return \Symfony\Component\Process\Process
+   *   The command process, after it has run.
+   */
+  private function runRecipeCommand(string ...$arguments): Process {
+    array_unshift($arguments, (new PhpExecutableFinder())->find(), 'core/scripts/drupal', 'recipe');
+
+    $process = (new Process($arguments))
+      ->setWorkingDirectory($this->getDrupalRoot())
+      ->setEnv([
+        'DRUPAL_DEV_SITE_PATH' => $this->siteDirectory,
+      ])
+      ->setTimeout(500);
+
+    $process->run();
+    // Applying a recipe:
+    // - creates new checkpoints, hence the "state" service in the test runner
+    //   is outdated
+    // - may install modules, which would cause the entire container in the test
+    //   runner to be outdated.
+    // Hence the entire environment must be rebuilt for assertions to target the
+    // actual post-recipe-application result.
+    // @see \Drupal\Core\Config\Checkpoint\LinearHistory::__construct()
+    $this->rebuildAll();
+    return $process;
+  }
+
+}
diff --git a/core/tests/Drupal/KernelTests/Core/Config/Action/ConfigActionTest.php b/core/tests/Drupal/KernelTests/Core/Config/Action/ConfigActionTest.php
new file mode 100644
index 0000000000..3681457776
--- /dev/null
+++ b/core/tests/Drupal/KernelTests/Core/Config/Action/ConfigActionTest.php
@@ -0,0 +1,322 @@
+<?php
+
+namespace Drupal\KernelTests\Core\Config\Action;
+
+// cspell:ignore inflector
+use Drupal\Component\Plugin\Exception\PluginNotFoundException;
+use Drupal\Component\Uuid\Uuid;
+use Drupal\config_test\ConfigActionErrorEntity\DuplicatePluralizedMethodName;
+use Drupal\config_test\ConfigActionErrorEntity\DuplicatePluralizedOtherMethodName;
+use Drupal\Core\Config\Action\ConfigActionException;
+use Drupal\Core\Config\Action\DuplicateConfigActionIdException;
+use Drupal\Core\Config\Action\EntityMethodException;
+use Drupal\KernelTests\KernelTestBase;
+
+/**
+ * Tests the config action system.
+ *
+ * @group config
+ */
+class ConfigActionTest extends KernelTestBase {
+
+  /**
+   * {@inheritdoc}
+   */
+  protected static $modules = ['config_test'];
+
+  /**
+   * @see \Drupal\Core\Config\Action\Plugin\ConfigAction\EntityCreate
+   */
+  public function testEntityCreate(): void {
+    $this->assertCount(0, \Drupal::entityTypeManager()->getStorage('config_test')->loadMultiple(), 'There are no config_test entities');
+    /** @var \Drupal\Core\Config\Action\ConfigActionManager $manager */
+    $manager = $this->container->get('plugin.manager.config_action');
+    $manager->applyAction('entity_create:ensure_exists', 'config_test.dynamic.action_test', ['label' => 'Action test']);
+    /** @var \Drupal\config_test\Entity\ConfigTest[] $config_test_entities */
+    $config_test_entities = \Drupal::entityTypeManager()->getStorage('config_test')->loadMultiple();
+    $this->assertCount(1, \Drupal::entityTypeManager()->getStorage('config_test')->loadMultiple(), 'There is 1 config_test entity');
+    $this->assertSame('Action test', $config_test_entities['action_test']->label());
+    $this->assertTrue(Uuid::isValid((string) $config_test_entities['action_test']->uuid()), 'Config entity assigned a valid UUID');
+
+    // Calling ensure exists action again will not error.
+    $manager->applyAction('entity_create:ensure_exists', 'config_test.dynamic.action_test', ['label' => 'Action test']);
+
+    try {
+      $manager->applyAction('entity_create:create', 'config_test.dynamic.action_test', ['label' => 'Action test']);
+      $this->fail('Expected exception not thrown');
+    }
+    catch (ConfigActionException $e) {
+      $this->assertSame('Entity config_test.dynamic.action_test exists', $e->getMessage());
+    }
+  }
+
+  /**
+   * @see \Drupal\Core\Config\Action\Plugin\ConfigAction\EntityMethod
+   */
+  public function testEntityMethod(): void {
+    $this->installConfig('config_test');
+    $storage = \Drupal::entityTypeManager()->getStorage('config_test');
+
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->load('dotted.default');
+    $this->assertSame('Default', $config_test_entity->getProtectedProperty());
+
+    /** @var \Drupal\Core\Config\Action\ConfigActionManager $manager */
+    $manager = $this->container->get('plugin.manager.config_action');
+    // Call a method action.
+    $manager->applyAction('entity_method:config_test.dynamic:setProtectedProperty', 'config_test.dynamic.dotted.default', 'Test value');
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->load('dotted.default');
+    $this->assertSame('Test value', $config_test_entity->getProtectedProperty());
+
+    $manager->applyAction('entity_method:config_test.dynamic:setProtectedProperty', 'config_test.dynamic.dotted.default', 'Test value 2');
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->load('dotted.default');
+    $this->assertSame('Test value 2', $config_test_entity->getProtectedProperty());
+
+    $manager->applyAction('entity_method:config_test.dynamic:concatProtectedProperty', 'config_test.dynamic.dotted.default', ['Test value ', '3']);
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->load('dotted.default');
+    $this->assertSame('Test value 3', $config_test_entity->getProtectedProperty());
+
+    $manager->applyAction('entity_method:config_test.dynamic:concatProtectedPropertyOptional', 'config_test.dynamic.dotted.default', ['Test value ', '4']);
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->load('dotted.default');
+    $this->assertSame('Test value 4', $config_test_entity->getProtectedProperty());
+
+    // Test calling an action that has 2 arguments but one is optional with an
+    // array value.
+    $manager->applyAction('entity_method:config_test.dynamic:concatProtectedPropertyOptional', 'config_test.dynamic.dotted.default', ['Test value 5']);
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->load('dotted.default');
+    $this->assertSame('Test value 5', $config_test_entity->getProtectedProperty());
+
+    // Test calling an action that has 2 arguments but one is optional with a
+    // non array value.
+    $manager->applyAction('entity_method:config_test.dynamic:concatProtectedPropertyOptional', 'config_test.dynamic.dotted.default', 'Test value 6');
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->load('dotted.default');
+    $this->assertSame('Test value 6', $config_test_entity->getProtectedProperty());
+
+    // Test calling an action that expects no arguments.
+    $manager->applyAction('entity_method:config_test.dynamic:defaultProtectedProperty', 'config_test.dynamic.dotted.default', []);
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->load('dotted.default');
+    $this->assertSame('Set by method', $config_test_entity->getProtectedProperty());
+
+    $manager->applyAction('entity_method:config_test.dynamic:addToArray', 'config_test.dynamic.dotted.default', 'foo');
+    $manager->applyAction('entity_method:config_test.dynamic:addToArray', 'config_test.dynamic.dotted.default', 'bar');
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->load('dotted.default');
+    $this->assertSame(['foo', 'bar'], $config_test_entity->getArrayProperty());
+
+    $manager->applyAction('entity_method:config_test.dynamic:addToArray', 'config_test.dynamic.dotted.default', ['a', 'b', 'c']);
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->load('dotted.default');
+    $this->assertSame(['foo', 'bar', ['a', 'b', 'c']], $config_test_entity->getArrayProperty());
+
+    $manager->applyAction('entity_method:config_test.dynamic:setArray', 'config_test.dynamic.dotted.default', ['a', 'b', 'c']);
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->load('dotted.default');
+    $this->assertSame(['a', 'b', 'c'], $config_test_entity->getArrayProperty());
+
+    $manager->applyAction('entity_method:config_test.dynamic:setArray', 'config_test.dynamic.dotted.default', [['a', 'b', 'c'], ['a']]);
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->load('dotted.default');
+    $this->assertSame([['a', 'b', 'c'], ['a']], $config_test_entity->getArrayProperty());
+
+    $config_test_entity->delete();
+    try {
+      $manager->applyAction('entity_method:config_test.dynamic:setProtectedProperty', 'config_test.dynamic.dotted.default', 'Test value');
+      $this->fail('Expected exception not thrown');
+    }
+    catch (ConfigActionException $e) {
+      $this->assertSame('Entity config_test.dynamic.dotted.default does not exist', $e->getMessage());
+    }
+
+    // Test custom and default admin labels.
+    $this->assertSame('Test configuration append', (string) $manager->getDefinition('entity_method:config_test.dynamic:append')['admin_label']);
+    $this->assertSame('Set default name', (string) $manager->getDefinition('entity_method:config_test.dynamic:defaultProtectedProperty')['admin_label']);
+  }
+
+  /**
+   * @see \Drupal\Core\Config\Action\Plugin\ConfigAction\EntityMethod
+   */
+  public function testPluralizedEntityMethod(): void {
+    $this->installConfig('config_test');
+    $storage = \Drupal::entityTypeManager()->getStorage('config_test');
+
+    /** @var \Drupal\Core\Config\Action\ConfigActionManager $manager */
+    $manager = $this->container->get('plugin.manager.config_action');
+    // Call a pluralized method action.
+    $manager->applyAction('entity_method:config_test.dynamic:addToArrayMultipleTimes', 'config_test.dynamic.dotted.default', ['a', 'b', 'c', 'd']);
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->load('dotted.default');
+    $this->assertSame(['a', 'b', 'c', 'd'], $config_test_entity->getArrayProperty());
+
+    $manager->applyAction('entity_method:config_test.dynamic:addToArrayMultipleTimes', 'config_test.dynamic.dotted.default', [['foo'], 'bar']);
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->load('dotted.default');
+    $this->assertSame(['a', 'b', 'c', 'd', ['foo'], 'bar'], $config_test_entity->getArrayProperty());
+
+    $config_test_entity->setProtectedProperty('')->save();
+    $manager->applyAction('entity_method:config_test.dynamic:appends', 'config_test.dynamic.dotted.default', ['1', '2', '3']);
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->load('dotted.default');
+    $this->assertSame('123', $config_test_entity->getProtectedProperty());
+
+    // Test that the inflector converts to a good plural form.
+    $config_test_entity->setProtectedProperty('')->save();
+    $manager->applyAction('entity_method:config_test.dynamic:concatProtectedProperties', 'config_test.dynamic.dotted.default', [['1', '2'], ['3', '4']]);
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->load('dotted.default');
+    $this->assertSame('34', $config_test_entity->getProtectedProperty());
+
+    $this->assertTrue($manager->hasDefinition('entity_method:config_test.dynamic:setProtectedProperty'), 'The setProtectedProperty action exists');
+    // cspell:ignore Propertys
+    $this->assertFalse($manager->hasDefinition('entity_method:config_test.dynamic:setProtectedPropertys'), 'There is no automatically pluralized version of the setProtectedProperty action');
+
+    // Admin label for pluralized form.
+    $this->assertSame('Test configuration append (multiple calls)', (string) $manager->getDefinition('entity_method:config_test.dynamic:appends')['admin_label']);
+  }
+
+  /**
+   * @see \Drupal\Core\Config\Action\Plugin\ConfigAction\EntityMethod
+   */
+  public function testPluralizedEntityMethodException(): void {
+    $this->installConfig('config_test');
+    /** @var \Drupal\Core\Config\Action\ConfigActionManager $manager */
+    $manager = $this->container->get('plugin.manager.config_action');
+    $this->expectException(EntityMethodException::class);
+    $this->expectExceptionMessage('The pluralized entity method config action \'entity_method:config_test.dynamic:addToArrayMultipleTimes\' requires an array value in order to call Drupal\config_test\Entity\ConfigTest::addToArray() multiple times');
+    $manager->applyAction('entity_method:config_test.dynamic:addToArrayMultipleTimes', 'config_test.dynamic.dotted.default', 'Test value');
+  }
+
+  /**
+   * @see \Drupal\Core\Config\Action\Plugin\ConfigAction\Deriver\EntityMethodDeriver
+   */
+  public function testDuplicatePluralizedMethodNameException(): void {
+    \Drupal::state()->set('config_test.class_override', DuplicatePluralizedMethodName::class);
+    \Drupal::entityTypeManager()->clearCachedDefinitions();
+    $this->installConfig('config_test');
+    /** @var \Drupal\Core\Config\Action\ConfigActionManager $manager */
+    $manager = $this->container->get('plugin.manager.config_action');
+    $this->expectException(EntityMethodException::class);
+    $this->expectExceptionMessage('Duplicate action can not be created for ID \'config_test.dynamic:testMethod\' for Drupal\config_test\ConfigActionErrorEntity\DuplicatePluralizedMethodName::testMethod(). The existing action is for the ::testMethod() method');
+    $manager->getDefinitions();
+  }
+
+  /**
+   * @see \Drupal\Core\Config\Action\Plugin\ConfigAction\Deriver\EntityMethodDeriver
+   */
+  public function testDuplicatePluralizedOtherMethodNameException(): void {
+    \Drupal::state()->set('config_test.class_override', DuplicatePluralizedOtherMethodName::class);
+    \Drupal::entityTypeManager()->clearCachedDefinitions();
+    $this->installConfig('config_test');
+    /** @var \Drupal\Core\Config\Action\ConfigActionManager $manager */
+    $manager = $this->container->get('plugin.manager.config_action');
+    $this->expectException(EntityMethodException::class);
+    $this->expectExceptionMessage('Duplicate action can not be created for ID \'config_test.dynamic:testMethod2\' for Drupal\config_test\ConfigActionErrorEntity\DuplicatePluralizedOtherMethodName::testMethod2(). The existing action is for the ::testMethod() method');
+    $manager->getDefinitions();
+  }
+
+  /**
+   * @see \Drupal\Core\Config\Action\Plugin\ConfigAction\EntityMethod
+   */
+  public function testEntityMethodException(): void {
+    $this->installConfig('config_test');
+    /** @var \Drupal\Core\Config\Action\ConfigActionManager $manager */
+    $manager = $this->container->get('plugin.manager.config_action');
+    $this->expectException(EntityMethodException::class);
+    $this->expectExceptionMessage('Entity method config action \'entity_method:config_test.dynamic:concatProtectedProperty\' requires an array value. The number of parameters or required parameters for Drupal\config_test\Entity\ConfigTest::concatProtectedProperty() is not 1');
+    $manager->applyAction('entity_method:config_test.dynamic:concatProtectedProperty', 'config_test.dynamic.dotted.default', 'Test value');
+  }
+
+  /**
+   * @see \Drupal\Core\Config\Action\Plugin\ConfigAction\SimpleConfigUpdate
+   */
+  public function testSimpleConfigUpdate(): void {
+    $this->installConfig('config_test');
+    $this->assertSame('bar', $this->config('config_test.system')->get('foo'));
+
+    /** @var \Drupal\Core\Config\Action\ConfigActionManager $manager */
+    $manager = $this->container->get('plugin.manager.config_action');
+    // Call the simple config update action.
+    $manager->applyAction('simple_config_update', 'config_test.system', ['foo' => 'Yay!']);
+    $this->assertSame('Yay!', $this->config('config_test.system')->get('foo'));
+
+    try {
+      $manager->applyAction('simple_config_update', 'config_test.system', 'Test');
+      $this->fail('Expected exception not thrown');
+    }
+    catch (ConfigActionException $e) {
+      $this->assertSame('Config config_test.system can not be updated because $value is not an array', $e->getMessage());
+    }
+
+    $this->config('config_test.system')->delete();
+    try {
+      $manager->applyAction('simple_config_update', 'config_test.system', ['foo' => 'Yay!']);
+      $this->fail('Expected exception not thrown');
+    }
+    catch (ConfigActionException $e) {
+      $this->assertSame('Config config_test.system does not exist so can not be updated', $e->getMessage());
+    }
+  }
+
+  /**
+   * @see \Drupal\Core\Config\Action\ConfigActionManager::getShorthandActionIdsForEntityType()
+   */
+  public function testShorthandActionIds(): void {
+    $storage = \Drupal::entityTypeManager()->getStorage('config_test');
+    $this->assertCount(0, $storage->loadMultiple(), 'There are no config_test entities');
+    /** @var \Drupal\Core\Config\Action\ConfigActionManager $manager */
+    $manager = $this->container->get('plugin.manager.config_action');
+    $manager->applyAction('ensure_exists', 'config_test.dynamic.action_test', ['label' => 'Action test', 'protected_property' => '']);
+    /** @var \Drupal\config_test\Entity\ConfigTest[] $config_test_entities */
+    $config_test_entities = $storage->loadMultiple();
+    $this->assertCount(1, $config_test_entities, 'There is 1 config_test entity');
+    $this->assertSame('Action test', $config_test_entities['action_test']->label());
+
+    $this->assertSame('', $config_test_entities['action_test']->getProtectedProperty());
+
+    /** @var \Drupal\Core\Config\Action\ConfigActionManager $manager */
+    $manager = $this->container->get('plugin.manager.config_action');
+    // Call a method action.
+    $manager->applyAction('setProtectedProperty', 'config_test.dynamic.action_test', 'Test value');
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->load('action_test');
+    $this->assertSame('Test value', $config_test_entity->getProtectedProperty());
+  }
+
+  /**
+   * @see \Drupal\Core\Config\Action\ConfigActionManager::getShorthandActionIdsForEntityType()
+   */
+  public function testDuplicateShorthandActionIds(): void {
+    $this->enableModules(['config_action_duplicate_test']);
+    /** @var \Drupal\Core\Config\Action\ConfigActionManager $manager */
+    $manager = $this->container->get('plugin.manager.config_action');
+    $this->expectException(DuplicateConfigActionIdException::class);
+    $this->expectExceptionMessage("The plugins 'entity_method:config_test.dynamic:setProtectedProperty' and 'config_action_duplicate_test:config_test.dynamic:setProtectedProperty' both resolve to the same shorthand action ID for the 'config_test' entity type");
+    $manager->applyAction('ensure_exists', 'config_test.dynamic.action_test', ['label' => 'Action test', 'protected_property' => '']);
+  }
+
+  /**
+   * @see \Drupal\Core\Config\Action\ConfigActionManager::getShorthandActionIdsForEntityType()
+   */
+  public function testParentAttributes(): void {
+    $definitions = $this->container->get('plugin.manager.config_action')->getDefinitions();
+    // The \Drupal\config_test\Entity\ConfigQueryTest::concatProtectedProperty()
+    // does not have an attribute but the parent does so this is discovered.
+    $this->assertArrayHasKey('entity_method:config_test.query:concatProtectedProperty', $definitions);
+  }
+
+  /**
+   * @see \Drupal\Core\Config\Action\ConfigActionManager
+   */
+  public function testMissingAction(): void {
+    $this->expectException(PluginNotFoundException::class);
+    $this->expectExceptionMessageMatches('/^The "does_not_exist" plugin does not exist/');
+    $this->container->get('plugin.manager.config_action')->applyAction('does_not_exist', 'config_test.system', ['foo' => 'Yay!']);
+  }
+
+}
diff --git a/core/tests/Drupal/KernelTests/Core/Config/ConfigImporterTest.php b/core/tests/Drupal/KernelTests/Core/Config/ConfigImporterTest.php
index 9f4b9aa31b..bf17339b8b 100644
--- a/core/tests/Drupal/KernelTests/Core/Config/ConfigImporterTest.php
+++ b/core/tests/Drupal/KernelTests/Core/Config/ConfigImporterTest.php
@@ -4,6 +4,7 @@
 
 use Drupal\Component\Utility\Html;
 use Drupal\Component\Render\FormattableMarkup;
+use Drupal\Core\Config\ConfigCollectionEvents;
 use Drupal\Core\Config\ConfigEvents;
 use Drupal\Core\Config\ConfigImporter;
 use Drupal\Core\Config\ConfigImporterException;
@@ -930,6 +931,44 @@ public function testConfigEvents(): void {
     $this->assertSame(['key' => 'bar'], $event['original_config_data']);
   }
 
+  /**
+   * Tests events and collections during a config import.
+   */
+  public function testEventsAndCollectionsImport(): void {
+    $collections = [
+      'another_collection',
+      'collection.test1',
+      'collection.test2',
+    ];
+    // Set the event listener to return three possible collections.
+    // @see \Drupal\config_collection_install_test\EventSubscriber
+    \Drupal::state()->set('config_collection_install_test.collection_names', $collections);
+    $this->enableModules(['config_collection_install_test']);
+    $this->installConfig(['config_collection_install_test']);
+
+    // Export the configuration and uninstall the module to test installing it
+    // via configuration import.
+    $this->copyConfig($this->container->get('config.storage'), $this->container->get('config.storage.sync'));
+    $this->container->get('module_installer')->uninstall(['config_collection_install_test']);
+    $this->assertEmpty($this->container->get('config.storage')->getAllCollectionNames());
+
+    \Drupal::state()->set('config_events_test.all_events', []);
+    $this->configImporter()->import();
+    $this->assertSame($collections, $this->container->get('config.storage')->getAllCollectionNames());
+
+    $all_events = \Drupal::state()->get('config_events_test.all_events');
+    $this->assertArrayHasKey('core.extension', $all_events[ConfigEvents::SAVE]);
+    // Ensure that config in collections does not have the regular configuration
+    // event triggered.
+    $this->assertArrayNotHasKey('config_collection_install_test.test', $all_events[ConfigEvents::SAVE]);
+    $this->assertCount(3, $all_events[ConfigCollectionEvents::SAVE_IN_COLLECTION]['config_collection_install_test.test']);
+    $event_collections = [];
+    foreach ($all_events[ConfigCollectionEvents::SAVE_IN_COLLECTION]['config_collection_install_test.test'] as $event) {
+      $event_collections[] = $event['current_config_data']['collection'];
+    }
+    $this->assertSame($collections, $event_collections);
+  }
+
   /**
    * Helper method to test custom config installer steps.
    *
diff --git a/core/tests/Drupal/KernelTests/Core/Config/ConfigInstallTest.php b/core/tests/Drupal/KernelTests/Core/Config/ConfigInstallTest.php
index 604ab1df36..4655ae374e 100644
--- a/core/tests/Drupal/KernelTests/Core/Config/ConfigInstallTest.php
+++ b/core/tests/Drupal/KernelTests/Core/Config/ConfigInstallTest.php
@@ -2,6 +2,7 @@
 
 namespace Drupal\KernelTests\Core\Config;
 
+use Drupal\Core\Config\ConfigCollectionEvents;
 use Drupal\Core\Config\InstallStorage;
 use Drupal\Core\Config\PreExistingConfigException;
 use Drupal\Core\Config\UnmetDependenciesException;
@@ -18,7 +19,7 @@ class ConfigInstallTest extends KernelTestBase {
   /**
    * {@inheritdoc}
    */
-  protected static $modules = ['system'];
+  protected static $modules = ['system', 'config_events_test'];
 
   /**
    * {@inheritdoc}
@@ -146,10 +147,25 @@ public function testCollectionInstallationCollections() {
 
     // Test that the config manager uninstalls configuration from collections
     // as expected.
-    \Drupal::service('config.manager')->uninstall('module', 'config_collection_install_test');
+    \Drupal::state()->set('config_events_test.all_events', []);
+    $this->container->get('config.manager')->uninstall('module', 'config_collection_install_test');
+    $all_events = \Drupal::state()->get('config_events_test.all_events');
+    $this->assertArrayHasKey(ConfigCollectionEvents::DELETE_IN_COLLECTION, $all_events);
+    // The delete-in-collection event has been triggered 3 times.
+    $this->assertCount(3, $all_events[ConfigCollectionEvents::DELETE_IN_COLLECTION]['config_collection_install_test.test']);
+    $event_collections = [];
+    foreach ($all_events[ConfigCollectionEvents::DELETE_IN_COLLECTION]['config_collection_install_test.test'] as $event) {
+      $event_collections[] = $event['original_config_data']['collection'];
+    }
+    $this->assertSame(['another_collection', 'collection.test1', 'collection.test2'], $event_collections);
     $this->assertEquals(['entity'], $active_storage->getAllCollectionNames());
-    \Drupal::service('config.manager')->uninstall('module', 'config_test');
+
+    \Drupal::state()->set('config_events_test.all_events', []);
+    $this->container->get('config.manager')->uninstall('module', 'config_test');
     $this->assertEquals([], $active_storage->getAllCollectionNames());
+    $all_events = \Drupal::state()->get('config_events_test.all_events');
+    $this->assertArrayHasKey(ConfigCollectionEvents::DELETE_IN_COLLECTION, $all_events);
+    $this->assertCount(1, $all_events[ConfigCollectionEvents::DELETE_IN_COLLECTION]['config_test.dynamic.dotted.default']);
   }
 
   /**
diff --git a/core/tests/Drupal/KernelTests/Core/Config/Storage/Checkpoint/CheckpointStorageTest.php b/core/tests/Drupal/KernelTests/Core/Config/Storage/Checkpoint/CheckpointStorageTest.php
new file mode 100644
index 0000000000..9032d234bc
--- /dev/null
+++ b/core/tests/Drupal/KernelTests/Core/Config/Storage/Checkpoint/CheckpointStorageTest.php
@@ -0,0 +1,310 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\KernelTests\Core\Config\Storage\Checkpoint;
+
+use Drupal\Core\Config\Checkpoint\CheckpointStorageInterface;
+use Drupal\Core\Config\ConfigImporter;
+use Drupal\Core\Config\StorageComparer;
+use Drupal\KernelTests\KernelTestBase;
+
+/**
+ * Tests CheckpointStorage operations.
+ *
+ * @group config
+ */
+class CheckpointStorageTest extends KernelTestBase {
+
+  /**
+   * {@inheritdoc}
+   */
+  protected static $modules = ['system', 'config_test'];
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function setUp(): void {
+    parent::setUp();
+    $this->installConfig(['system', 'config_test']);
+  }
+
+  public function testConfigSaveAndRead(): void {
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+
+    $this->config('system.site')->set('name', 'Test1')->save();
+    $check1 = $checkpoint_storage->checkpoint('A');
+    $this->config('system.site')->set('name', 'Test2')->save();
+    $check2 = $checkpoint_storage->checkpoint('B');
+    $this->config('system.site')->set('name', 'Test3')->save();
+
+    $this->assertSame('Test3', $this->config('system.site')->get('name'));
+    $this->assertSame('Test1', $checkpoint_storage->read('system.site')['name']);
+
+    // The config listings should be exactly the same.
+    $this->assertSame($checkpoint_storage->listAll(), $this->container->get('config.storage')->listAll());
+
+    $checkpoint_storage->setCheckpointToReadFrom($check2);
+    $this->assertSame('Test2', $checkpoint_storage->read('system.site')['name']);
+    $this->assertSame($checkpoint_storage->listAll(), $this->container->get('config.storage')->listAll());
+
+    $checkpoint_storage->setCheckpointToReadFrom($check1);
+    $this->assertSame('Test1', $checkpoint_storage->read('system.site')['name']);
+    $this->assertSame($checkpoint_storage->listAll(), $this->container->get('config.storage')->listAll());
+  }
+
+  public function testConfigDelete(): void {
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+
+    $check1 = $checkpoint_storage->checkpoint('A');
+    $this->config('config_test.system')->delete();
+
+    $this->assertFalse($this->container->get('config.storage')->exists('config_test.system'));
+    $this->assertTrue($checkpoint_storage->exists('config_test.system'));
+    $this->assertSame('bar', $checkpoint_storage->read('config_test.system')['foo']);
+
+    $this->assertContains('config_test.system', $checkpoint_storage->listAll());
+    $this->assertContains('config_test.system', $checkpoint_storage->listAll('config_test.'));
+    $this->assertNotContains('config_test.system', $checkpoint_storage->listAll('system.'));
+    // Should not be part of the active storage anymore.
+    $this->assertNotContains('config_test.system', $this->container->get('config.storage')->listAll());
+
+    $check2 = $checkpoint_storage->checkpoint('B');
+
+    $this->config('config_test.system')->set('foo', 'foobar')->save();
+    $this->assertTrue($this->container->get('config.storage')->exists('config_test.system'));
+    $this->assertTrue($checkpoint_storage->exists('config_test.system'));
+    $this->assertSame('bar', $checkpoint_storage->read('config_test.system')['foo']);
+
+    $checkpoint_storage->setCheckpointToReadFrom($check2);
+    $this->assertFalse($checkpoint_storage->exists('config_test.system'));
+    $this->assertFalse($checkpoint_storage->read('config_test.system'));
+    $this->assertNotContains('config_test.system', $checkpoint_storage->listAll());
+
+    $checkpoint_storage->setCheckpointToReadFrom($check1);
+    $this->assertTrue($checkpoint_storage->exists('config_test.system'));
+    $this->assertSame('bar', $checkpoint_storage->read('config_test.system')['foo']);
+    $this->assertContains('config_test.system', $checkpoint_storage->listAll());
+  }
+
+  public function testConfigCreate(): void {
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+
+    $this->config('config_test.system')->delete();
+    $check1 = $checkpoint_storage->checkpoint('A');
+    $this->config('config_test.system')->set('foo', 'foobar')->save();
+
+    $this->assertTrue($this->container->get('config.storage')->exists('config_test.system'));
+    $this->assertFalse($checkpoint_storage->exists('config_test.system'));
+    $this->assertFalse($checkpoint_storage->read('config_test.system'));
+
+    $this->assertNotContains('config_test.system', $checkpoint_storage->listAll());
+    $this->assertNotContains('config_test.system', $checkpoint_storage->listAll('config_test.'));
+    $this->assertContains('system.site', $checkpoint_storage->listAll('system.'));
+    $this->assertContains('config_test.system', $this->container->get('config.storage')->listAll());
+
+    $check2 = $checkpoint_storage->checkpoint('B');
+    $this->config('config_test.system')->delete();
+
+    $this->assertFalse($this->container->get('config.storage')->exists('config_test.system'));
+    $this->assertFalse($checkpoint_storage->exists('config_test.system'));
+    $this->assertFalse($checkpoint_storage->read('config_test.system'));
+
+    $this->config('config_test.system')->set('foo', 'foobar')->save();
+    $this->assertTrue($this->container->get('config.storage')->exists('config_test.system'));
+    $this->assertFalse($checkpoint_storage->exists('config_test.system'));
+    $this->assertFalse($checkpoint_storage->read('config_test.system'));
+
+    $checkpoint_storage->setCheckpointToReadFrom($check2);
+    $this->assertTrue($checkpoint_storage->exists('config_test.system'));
+    $this->assertSame('foobar', $checkpoint_storage->read('config_test.system')['foo']);
+    $this->assertContains('config_test.system', $checkpoint_storage->listAll());
+
+    $checkpoint_storage->setCheckpointToReadFrom($check1);
+    $this->assertFalse($checkpoint_storage->exists('config_test.system'));
+    $this->assertFalse($checkpoint_storage->read('config_test.system'));
+    $this->assertNotContains('config_test.system', $checkpoint_storage->listAll());
+  }
+
+  public function testConfigRename(): void {
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+    $check1 = $checkpoint_storage->checkpoint('A');
+    $this->container->get('config.factory')->rename('config_test.dynamic.dotted.default', 'config_test.dynamic.renamed');
+    $this->config('config_test.dynamic.renamed')->set('id', 'renamed')->save();
+
+    $this->assertFalse($checkpoint_storage->exists('config_test.dynamic.renamed'));
+    $this->assertTrue($checkpoint_storage->exists('config_test.dynamic.dotted.default'));
+    $this->assertSame('dotted.default', $checkpoint_storage->read('config_test.dynamic.dotted.default')['id']);
+    $this->assertSame($checkpoint_storage->read('config_test.dynamic.dotted.default')['uuid'], $this->config('config_test.dynamic.renamed')->get('uuid'));
+
+    $check2 = $checkpoint_storage->checkpoint('B');
+    /** @var \Drupal\Core\Config\Entity\ConfigEntityStorage $storage */
+    $storage = $this->container->get('entity_type.manager')->getStorage('config_test');
+    // Entity1 will be deleted by the test.
+    $entity1 = $storage->create(
+      [
+        'id' => 'dotted.default',
+        'label' => 'Another one',
+      ]
+    );
+    $entity1->save();
+
+    $check3 = $checkpoint_storage->checkpoint('C');
+
+    $checkpoint_storage->setCheckpointToReadFrom($check2);
+    $this->assertFalse($checkpoint_storage->exists('config_test.dynamic.dotted.default'));
+
+    $checkpoint_storage->setCheckpointToReadFrom($check3);
+    $this->assertTrue($checkpoint_storage->exists('config_test.dynamic.dotted.default'));
+    $this->assertNotEquals($checkpoint_storage->read('config_test.dynamic.dotted.default')['uuid'], $this->config('config_test.dynamic.renamed')->get('uuid'));
+    $this->assertSame('Another one', $checkpoint_storage->read('config_test.dynamic.dotted.default')['label']);
+
+    $checkpoint_storage->setCheckpointToReadFrom($check1);
+    $this->assertSame('Default', $checkpoint_storage->read('config_test.dynamic.dotted.default')['label']);
+  }
+
+  public function testRevert(): void {
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+    $check1 = $checkpoint_storage->checkpoint('A');
+    $this->assertTrue($this->container->get('module_installer')->uninstall(['config_test']));
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+    $check2 = $checkpoint_storage->checkpoint('B');
+
+    $importer = $this->getConfigImporter($checkpoint_storage);
+    $config_changelist = $importer->getStorageComparer()->createChangelist()->getChangelist();
+    $this->assertContains('config_test.dynamic.dotted.default', $config_changelist['create']);
+    $this->assertSame(['core.extension'], $config_changelist['update']);
+    $this->assertSame([], $config_changelist['delete']);
+    $this->assertSame([], $config_changelist['rename']);
+
+    $importer->import();
+    $this->assertSame([], $importer->getErrors());
+
+    $this->assertTrue($this->container->get('module_handler')->moduleExists('config_test'));
+
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+    $checkpoint_storage->setCheckpointToReadFrom($check2);
+
+    $importer = $this->getConfigImporter($checkpoint_storage);
+    $config_changelist = $importer->getStorageComparer()->createChangelist()->getChangelist();
+    $this->assertContains('config_test.dynamic.dotted.default', $config_changelist['delete']);
+    $this->assertSame(['core.extension'], $config_changelist['update']);
+    $this->assertSame([], $config_changelist['create']);
+    $this->assertSame([], $config_changelist['rename']);
+    $importer->import();
+    $this->assertFalse($this->container->get('module_handler')->moduleExists('config_test'));
+
+    $checkpoint_storage->setCheckpointToReadFrom($check1);
+    $importer = $this->getConfigImporter($checkpoint_storage);
+    $importer->getStorageComparer()->createChangelist();
+    $importer->import();
+    $this->assertTrue($this->container->get('module_handler')->moduleExists('config_test'));
+  }
+
+  public function testRevertWithCollections(): void {
+    $collections = [
+      'another_collection',
+      'collection.test1',
+      'collection.test2',
+    ];
+    // Set the event listener to return three possible collections.
+    // @see \Drupal\config_collection_install_test\EventSubscriber
+    \Drupal::state()->set('config_collection_install_test.collection_names', $collections);
+
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+    $checkpoint_storage->checkpoint('A');
+
+    // Install the test module.
+    $this->assertTrue($this->container->get('module_installer')->install(['config_collection_install_test']));
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+
+    /** @var \Drupal\Core\Config\StorageInterface $active_storage */
+    $active_storage = \Drupal::service('config.storage');
+    $this->assertEquals($collections, $active_storage->getAllCollectionNames());
+    foreach ($collections as $collection) {
+      $collection_storage = $active_storage->createCollection($collection);
+      $data = $collection_storage->read('config_collection_install_test.test');
+      $this->assertEquals($collection, $data['collection']);
+    }
+
+    $check2 = $checkpoint_storage->checkpoint('B');
+
+    $importer = $this->getConfigImporter($checkpoint_storage);
+    $storage_comparer = $importer->getStorageComparer();
+    $config_changelist = $storage_comparer->createChangelist()->getChangelist();
+    $this->assertSame([], $config_changelist['create']);
+    $this->assertSame(['core.extension'], $config_changelist['update']);
+    $this->assertSame([], $config_changelist['delete']);
+    $this->assertSame([], $config_changelist['rename']);
+    foreach ($collections as $collection) {
+      $config_changelist = $storage_comparer->getChangelist(NULL, $collection);
+      $this->assertSame([], $config_changelist['create']);
+      $this->assertSame([], $config_changelist['update']);
+      $this->assertSame(['config_collection_install_test.test'], $config_changelist['delete'], $collection);
+      $this->assertSame([], $config_changelist['rename']);
+    }
+
+    $importer->import();
+    $this->assertSame([], $importer->getErrors());
+
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+    /** @var \Drupal\Core\Config\StorageInterface $active_storage */
+    $active_storage = \Drupal::service('config.storage');
+    $this->assertEmpty($active_storage->getAllCollectionNames());
+    foreach ($collections as $collection) {
+      $collection_storage = $active_storage->createCollection($collection);
+      $this->assertFalse($collection_storage->read('config_collection_install_test.test'));
+    }
+
+    $checkpoint_storage->setCheckpointToReadFrom($check2);
+
+    $importer = $this->getConfigImporter($checkpoint_storage);
+
+    $storage_comparer = $importer->getStorageComparer();
+    $config_changelist = $storage_comparer->createChangelist()->getChangelist();
+    $this->assertSame([], $config_changelist['create']);
+    $this->assertSame(['core.extension'], $config_changelist['update']);
+    $this->assertSame([], $config_changelist['delete']);
+    $this->assertSame([], $config_changelist['rename']);
+    foreach ($collections as $collection) {
+      $config_changelist = $storage_comparer->getChangelist(NULL, $collection);
+      $this->assertSame(['config_collection_install_test.test'], $config_changelist['create']);
+      $this->assertSame([], $config_changelist['update']);
+      $this->assertSame([], $config_changelist['delete'], $collection);
+      $this->assertSame([], $config_changelist['rename']);
+    }
+    $importer->import();
+    $this->assertSame([], $importer->getErrors());
+
+    $this->assertTrue($this->container->get('module_handler')->moduleExists('config_collection_install_test'));
+    /** @var \Drupal\Core\Config\StorageInterface $active_storage */
+    $active_storage = \Drupal::service('config.storage');
+    $this->assertEquals($collections, $active_storage->getAllCollectionNames());
+    foreach ($collections as $collection) {
+      $collection_storage = $active_storage->createCollection($collection);
+      $data = $collection_storage->read('config_collection_install_test.test');
+      $this->assertEquals($collection, $data['collection']);
+    }
+  }
+
+  private function getConfigImporter(CheckpointStorageInterface $storage): ConfigImporter {
+    $storage_comparer = new StorageComparer(
+      $storage,
+      $this->container->get('config.storage')
+    );
+    return new ConfigImporter(
+      $storage_comparer,
+      $this->container->get('event_dispatcher'),
+      $this->container->get('config.manager'),
+      $this->container->get('lock'),
+      $this->container->get('config.typed'),
+      $this->container->get('module_handler'),
+      $this->container->get('module_installer'),
+      $this->container->get('theme_handler'),
+      $this->container->get('string_translation'),
+      $this->container->get('extension.list.module'),
+      $this->container->get('extension.list.theme')
+    );
+  }
+
+}
diff --git a/core/tests/Drupal/KernelTests/Core/Recipe/ConfigConfiguratorTest.php b/core/tests/Drupal/KernelTests/Core/Recipe/ConfigConfiguratorTest.php
new file mode 100644
index 0000000000..b91ea75b37
--- /dev/null
+++ b/core/tests/Drupal/KernelTests/Core/Recipe/ConfigConfiguratorTest.php
@@ -0,0 +1,46 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\KernelTests\Core\Recipe;
+
+use Drupal\Component\Serialization\Yaml;
+use Drupal\Core\Recipe\Recipe;
+use Drupal\KernelTests\KernelTestBase;
+
+/**
+ * @covers \Drupal\Core\Recipe\ConfigConfigurator
+ * @group Recipe
+ */
+class ConfigConfiguratorTest extends KernelTestBase {
+
+  public function testExistingConfigWithKeysInDifferentOrder(): void {
+    $recipe_dir = uniqid('public://recipe_test_');
+    mkdir($recipe_dir . '/config', recursive: TRUE);
+
+    $this->enableModules(['system']);
+    $this->installConfig('system');
+    /** @var mixed[][] $original_data */
+    $original_data = $this->config('system.site')->get();
+    // Remove keys that are ignored during the comparison.
+    unset($original_data['uuid'], $original_data['_core']);
+    $recipe_data = $original_data;
+    // Reorder an inner array, to ensure keys are sorted recursively.
+    $recipe_data['page'] = array_reverse($original_data['page'], TRUE);
+    $this->assertNotSame($original_data, $recipe_data);
+    file_put_contents($recipe_dir . '/config/system.site.yml', Yaml::encode($recipe_data));
+
+    $recipe = [
+      'name' => 'Same config, different order',
+      'type' => 'Testing',
+    ];
+    file_put_contents($recipe_dir . '/recipe.yml', Yaml::encode($recipe));
+
+    // If there was a conflict with the pre-existing config, ConfigConfigurator
+    // would throw an exception and the recipe would not be created. So all we
+    // need to do here is assert that, in fact, we were able to create a recipe
+    // object.
+    $this->assertInstanceOf(Recipe::class, Recipe::createFromDirectory($recipe_dir));
+  }
+
+}
diff --git a/core/tests/Drupal/KernelTests/Core/Recipe/RecipeDiscoveryTest.php b/core/tests/Drupal/KernelTests/Core/Recipe/RecipeDiscoveryTest.php
new file mode 100644
index 0000000000..faf87866ee
--- /dev/null
+++ b/core/tests/Drupal/KernelTests/Core/Recipe/RecipeDiscoveryTest.php
@@ -0,0 +1,58 @@
+<?php
+
+namespace Drupal\KernelTests\Core\Recipe;
+
+use Drupal\Core\Recipe\RecipeDiscovery;
+use Drupal\Core\Recipe\UnknownRecipeException;
+use Drupal\KernelTests\KernelTestBase;
+
+/**
+ * @coversDefaultClass \Drupal\Core\Recipe\RecipeDiscovery
+ * @group Recipe
+ */
+class RecipeDiscoveryTest extends KernelTestBase {
+
+  public function providerRecipeDiscovery(): array {
+    return [
+      ['install_two_modules', 'Install two modules'],
+      ['recipe_include', 'Recipe include'],
+    ];
+  }
+
+  /**
+   * Tests that recipe discovery can find recipes.
+   *
+   * @dataProvider providerRecipeDiscovery
+   */
+  public function testRecipeDiscovery(string $recipe, string $name): void {
+    $discovery = new RecipeDiscovery(['core/tests/fixtures/recipes']);
+    $recipe = $discovery->getRecipe($recipe);
+    $this->assertSame($name, $recipe->name);
+  }
+
+  public function providerRecipeDiscoveryException(): array {
+    return [
+      'missing recipe.yml' => ['no_recipe'],
+      'no folder' => ['does_not_exist'],
+    ];
+  }
+
+  /**
+   * Tests the exception thrown when recipe discovery cannot find a recipe.
+   *
+   * @dataProvider providerRecipeDiscoveryException
+   */
+  public function testRecipeDiscoveryException(string $recipe): void {
+    $discovery = new RecipeDiscovery(['core/tests/fixtures/recipes']);
+    try {
+      $discovery->getRecipe($recipe);
+      $this->fail('Expected exception not thrown');
+    }
+    catch (UnknownRecipeException $e) {
+      $this->assertSame($recipe, $e->recipe);
+      $this->assertSame(['core/tests/fixtures/recipes'], $e->searchPaths);
+      $this->assertSame('Can not find the ' . $recipe . ' recipe, search paths: core/tests/fixtures/recipes', $e->getMessage());
+    }
+  }
+
+}
diff --git a/core/tests/Drupal/KernelTests/Core/Recipe/RecipeRunnerTest.php b/core/tests/Drupal/KernelTests/Core/Recipe/RecipeRunnerTest.php
new file mode 100644
index 0000000000..f7042a78c7
--- /dev/null
+++ b/core/tests/Drupal/KernelTests/Core/Recipe/RecipeRunnerTest.php
@@ -0,0 +1,209 @@
+<?php
+
+namespace Drupal\KernelTests\Core\Recipe;
+
+use Drupal\Core\Recipe\Recipe;
+use Drupal\Core\Recipe\RecipePreExistingConfigException;
+use Drupal\Core\Recipe\RecipeRunner;
+use Drupal\Core\Recipe\RecipeUnmetDependenciesException;
+use Drupal\KernelTests\KernelTestBase;
+use Drupal\node\Entity\NodeType;
+use Drupal\views\Entity\View;
+
+/**
+ * @coversDefaultClass \Drupal\Core\Recipe\RecipeRunner
+ * @group Recipe
+ */
+class RecipeRunnerTest extends KernelTestBase {
+
+  public function testModuleInstall(): void {
+    // Test the state prior to applying the recipe.
+    $this->assertFalse($this->container->get('module_handler')->moduleExists('filter'), 'The filter module is not installed');
+    $this->assertFalse($this->container->get('module_handler')->moduleExists('text'), 'The text module is not installed');
+    $this->assertFalse($this->container->get('module_handler')->moduleExists('node'), 'The node module is not installed');
+    $this->assertFalse($this->container->get('config.storage')->exists('node.settings'), 'The node.settings configuration does not exist');
+
+    $recipe = Recipe::createFromDirectory('core/tests/fixtures/recipes/install_two_modules');
+    RecipeRunner::processRecipe($recipe);
+
+    // Test the state after applying the recipe.
+    $this->assertTrue($this->container->get('module_handler')->moduleExists('filter'), 'The filter module is installed');
+    $this->assertTrue($this->container->get('module_handler')->moduleExists('text'), 'The text module is installed');
+    $this->assertTrue($this->container->get('module_handler')->moduleExists('node'), 'The node module is installed');
+    $this->assertTrue($this->container->get('config.storage')->exists('node.settings'), 'The node.settings configuration has been created');
+    $this->assertFalse($this->config('node.settings')->get('use_admin_theme'), 'The node.settings:use_admin_theme is set to FALSE');
+  }
+
+  public function testModuleAndThemeInstall(): void {
+    $recipe = Recipe::createFromDirectory('core/tests/fixtures/recipes/base_theme_and_views');
+    RecipeRunner::processRecipe($recipe);
+
+    // Test the state after applying the recipe.
+    $this->assertTrue($this->container->get('module_handler')->moduleExists('views'), 'The views module is installed');
+    $this->assertTrue($this->container->get('module_handler')->moduleExists('node'), 'The node module is installed');
+    $this->assertTrue($this->container->get('theme_handler')->themeExists('test_basetheme'), 'The test_basetheme theme is installed');
+    $this->assertTrue($this->container->get('theme_handler')->themeExists('test_subtheme'), 'The test_subtheme theme is installed');
+    $this->assertTrue($this->container->get('theme_handler')->themeExists('test_subsubtheme'), 'The test_subsubtheme theme is installed');
+    $this->assertTrue($this->container->get('config.storage')->exists('node.settings'), 'The node.settings configuration has been created');
+    $this->assertFalse($this->container->get('config.storage')->exists('views.view.archive'), 'The views.view.archive configuration has not been created');
+    $this->assertEmpty(View::loadMultiple(), "No views exist");
+  }
+
+  public function testThemeModuleDependenciesInstall(): void {
+    $recipe = Recipe::createFromDirectory('core/tests/fixtures/recipes/theme_with_module_dependencies');
+    RecipeRunner::processRecipe($recipe);
+
+    // Test the state after applying the recipe.
+    $this->assertTrue($this->container->get('module_handler')->moduleExists('test_module_required_by_theme'), 'The test_module_required_by_theme module is installed');
+    $this->assertTrue($this->container->get('module_handler')->moduleExists('test_another_module_required_by_theme'), 'The test_another_module_required_by_theme module is installed');
+    $this->assertTrue($this->container->get('theme_handler')->themeExists('test_theme_depending_on_modules'), 'The test_theme_depending_on_modules theme is installed');
+  }
+
+  public function testModuleConfigurationOverride(): void {
+    // Test the state prior to applying the recipe.
+    $this->assertEmpty($this->container->get('config.factory')->listAll('node.'), 'There is no node configuration');
+
+    $recipe = Recipe::createFromDirectory('core/tests/fixtures/recipes/install_node_with_config');
+    RecipeRunner::processRecipe($recipe);
+
+    // Test the state after applying the recipe.
+    $this->assertTrue($this->container->get('config.storage')->exists('node.settings'), 'The node.settings configuration has been created');
+    $this->assertTrue($this->container->get('config.storage')->exists('node.settings'), 'The node.settings configuration has been created');
+    $this->assertTrue($this->config('node.settings')->get('use_admin_theme'), 'The node.settings:use_admin_theme is set to TRUE');
+    $this->assertSame('Test content type', NodeType::load('test')->label());
+    $node_type_data = $this->config('node.type.test')->get();
+    $this->assertGreaterThan(0, strlen($node_type_data['uuid']), 'The node type configuration has been assigned a UUID.');
+    // cSpell:disable-next-line
+    $this->assertSame('965SCwSA3qgVf47x7hEE4dufnUDpxKMsUfsqFtqjGn0', $node_type_data['_core']['default_config_hash']);
+  }
+
+  public function testUnmetConfigurationDependencies(): void {
+    $recipe = Recipe::createFromDirectory('core/tests/fixtures/recipes/unmet_config_dependencies');
+    try {
+      RecipeRunner::processRecipe($recipe);
+      $this->fail('Expected exception not thrown');
+    }
+    catch (RecipeUnmetDependenciesException $e) {
+      $this->assertSame("The configuration 'node.type.test' has unmet dependencies", $e->getMessage());
+      $this->assertSame('node.type.test', $e->configName);
+    }
+  }
+
+  public function testApplySameRecipe(): void {
+    // Test the state prior to applying the recipe.
+    $this->assertEmpty($this->container->get('config.factory')->listAll('node.'), 'There is no node configuration');
+
+    $recipe = Recipe::createFromDirectory('core/tests/fixtures/recipes/install_node_with_config');
+    RecipeRunner::processRecipe($recipe);
+
+    // Test the state prior to applying the recipe.
+    $this->assertNotEmpty($this->container->get('config.factory')->listAll('node.'), 'There is node configuration');
+
+    $recipe = Recipe::createFromDirectory('core/tests/fixtures/recipes/install_node_with_config');
+    RecipeRunner::processRecipe($recipe);
+    $this->assertTrue(TRUE, 'Applying a recipe for the second time with no config changes results in a successful application');
+
+    $type = NodeType::load('test');
+    $type->setNewRevision(FALSE);
+    $type->save();
+
+    $this->expectException(RecipePreExistingConfigException::class);
+    $this->expectExceptionMessage("The configuration 'node.type.test' exists already and does not match the recipe's configuration");
+    Recipe::createFromDirectory('core/tests/fixtures/recipes/install_node_with_config');
+  }
+
+  public function testConfigFromModule(): void {
+    // Test the state prior to applying the recipe.
+    $this->assertEmpty($this->container->get('config.factory')->listAll('config_test.'), 'There is no config_test configuration');
+
+    $recipe = Recipe::createFromDirectory('core/tests/fixtures/recipes/config_from_module');
+    RecipeRunner::processRecipe($recipe);
+
+    // Test the state after to applying the recipe.
+    $this->assertNotEmpty($this->container->get('config.factory')->listAll('config_test.'), 'There is config_test configuration');
+    $config_test_entities = \Drupal::entityTypeManager()->getStorage('config_test')->loadMultiple();
+    $this->assertSame(['dotted.default', 'override'], array_keys($config_test_entities));
+  }
+
+  public function testConfigWildcard(): void {
+    // Test the state prior to applying the recipe.
+    $this->assertEmpty($this->container->get('config.factory')->listAll('config_test.'), 'There is no config_test configuration');
+
+    $recipe = Recipe::createFromDirectory('core/tests/fixtures/recipes/config_wildcard');
+    RecipeRunner::processRecipe($recipe);
+
+    // Test the state after to applying the recipe.
+    $this->assertNotEmpty($this->container->get('config.factory')->listAll('config_test.'), 'There is config_test configuration');
+    $config_test_entities = \Drupal::entityTypeManager()->getStorage('config_test')->loadMultiple();
+    $this->assertSame(['dotted.default', 'override', 'override_unmet'], array_keys($config_test_entities));
+    $this->assertSame('Default', $config_test_entities['dotted.default']->label());
+    $this->assertSame('herp', $this->config('config_test.system')->get('404'));
+  }
+
+  public function testConfigFromModuleAndRecipe(): void {
+    // Test the state prior to applying the recipe.
+    $this->assertEmpty($this->container->get('config.factory')->listAll('config_test.'), 'There is no config_test configuration');
+
+    $recipe = Recipe::createFromDirectory('core/tests/fixtures/recipes/config_from_module_and_recipe');
+    RecipeRunner::processRecipe($recipe);
+
+    // Test the state after to applying the recipe.
+    $this->assertNotEmpty($this->container->get('config.factory')->listAll('config_test.'), 'There is config_test configuration');
+    $config_test_entities = \Drupal::entityTypeManager()->getStorage('config_test')->loadMultiple();
+    $this->assertSame(['dotted.default', 'override', 'override_unmet'], array_keys($config_test_entities));
+    $this->assertSame('Provided by recipe', $config_test_entities['dotted.default']->label());
+    $this->assertSame('foo', $this->config('config_test.system')->get('404'));
+  }
+
+  public function testRecipeInclude(): void {
+    // Test the state prior to applying the recipe.
+    $this->assertEmpty($this->container->get('config.factory')->listAll('node.'), 'There is no node configuration');
+    $this->assertFalse($this->container->get('module_handler')->moduleExists('dblog'), 'Dblog module not installed');
+
+    $recipe = Recipe::createFromDirectory('core/tests/fixtures/recipes/recipe_include');
+    RecipeRunner::processRecipe($recipe);
+
+    // Test the state after to applying the recipe.
+    $this->assertTrue($this->container->get('module_handler')->moduleExists('dblog'), 'Dblog module installed');
+    $this->assertSame('Test content type', NodeType::load('test')->label());
+    $this->assertSame('Another test content type', NodeType::load('another_test')->label());
+  }
+
+  public function testConfigActions() :void {
+    // Test the state prior to applying the recipe.
+    $this->assertEmpty($this->container->get('config.factory')->listAll('config_test.'), 'There is no config_test configuration');
+
+    $recipe = Recipe::createFromDirectory('core/tests/fixtures/recipes/config_actions');
+    RecipeRunner::processRecipe($recipe);
+
+    // Test the state after to applying the recipe.
+    $storage = \Drupal::entityTypeManager()->getStorage('config_test');
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->load('recipe');
+    $this->assertSame('Created by recipe', $config_test_entity->label());
+    $this->assertSame('Set by recipe', $config_test_entity->getProtectedProperty());
+    $this->assertSame('not bar', $this->config('config_test.system')->get('foo'));
+  }
+
+  public function testConfigActionsPreExistingConfig() :void {
+    $this->enableModules(['config_test']);
+    $this->installConfig(['config_test']);
+    $this->assertSame('bar', $this->config('config_test.system')->get('foo'));
+    $storage = \Drupal::entityTypeManager()->getStorage('config_test');
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->create(['id' => 'recipe', 'label' => 'Created by test']);
+    $config_test_entity->setProtectedProperty('Set by test');
+    $config_test_entity->save();
+
+    $recipe = Recipe::createFromDirectory('core/tests/fixtures/recipes/config_actions');
+    RecipeRunner::processRecipe($recipe);
+
+    // Test the state after to applying the recipe.
+    /** @var \Drupal\config_test\Entity\ConfigTest $config_test_entity */
+    $config_test_entity = $storage->load('recipe');
+    $this->assertSame('Created by test', $config_test_entity->label());
+    $this->assertSame('Set by recipe', $config_test_entity->getProtectedProperty());
+    $this->assertSame('not bar', $this->config('config_test.system')->get('foo'));
+  }
+
+}
diff --git a/core/tests/Drupal/KernelTests/Core/Recipe/RecipeTest.php b/core/tests/Drupal/KernelTests/Core/Recipe/RecipeTest.php
new file mode 100644
index 0000000000..56a52fb877
--- /dev/null
+++ b/core/tests/Drupal/KernelTests/Core/Recipe/RecipeTest.php
@@ -0,0 +1,108 @@
+<?php
+
+namespace Drupal\KernelTests\Core\Recipe;
+
+use Drupal\Core\Recipe\Recipe;
+use Drupal\Core\Recipe\RecipeFileException;
+use Drupal\Core\Recipe\RecipeMissingExtensionsException;
+use Drupal\Core\Recipe\RecipePreExistingConfigException;
+use Drupal\Core\Recipe\UnknownRecipeException;
+use Drupal\KernelTests\KernelTestBase;
+
+/**
+ * @coversDefaultClass \Drupal\Core\Recipe\Recipe
+ * @group Recipe
+ */
+class RecipeTest extends KernelTestBase {
+
+  /**
+   * {@inheritdoc}
+   */
+  protected static $modules = ['system', 'user', 'field'];
+
+  public function providerTestCreateFromDirectory(): array {
+    return [
+      'no extensions' => ['no_extensions', 'No extensions' , 'Testing', [], 'A recipe description'],
+      // Filter is installed because it is a dependency and it is not yet installed.
+      'install_two_modules' => ['install_two_modules', 'Install two modules' , 'Content type', ['filter', 'text', 'node'], ''],
+    ];
+  }
+
+  /**
+   * @dataProvider providerTestCreateFromDirectory
+   */
+  public function testCreateFromDirectory2(string $recipe_name, string $expected_name, string $expected_type, array $expected_modules, string $expected_description): void {
+    $recipe = Recipe::createFromDirectory('core/tests/fixtures/recipes/' . $recipe_name);
+    $this->assertSame($expected_name, $recipe->name);
+    $this->assertSame($expected_type, $recipe->type);
+    $this->assertSame($expected_modules, $recipe->install->modules);
+    $this->assertSame($expected_description, $recipe->description);
+  }
+
+  public function testCreateFromDirectoryNoRecipe(): void {
+    $this->expectException(RecipeFileException::class);
+    $this->expectExceptionMessage('There is no core/tests/fixtures/recipes/no_recipe/recipe.yml file');
+    Recipe::createFromDirectory('core/tests/fixtures/recipes/no_recipe');
+  }
+
+  public function testCreateFromDirectoryNoRecipeName(): void {
+    $this->expectException(RecipeFileException::class);
+    $this->expectExceptionMessage('The core/tests/fixtures/recipes/no_name/recipe.yml has no name value.');
+    Recipe::createFromDirectory('core/tests/fixtures/recipes/no_name');
+  }
+
+  public function testCreateFromDirectoryMissingExtensions(): void {
+    $this->enableModules(['module_test']);
+
+    // Create a missing fake dependency.
+    // dblog will depend on Config, which depends on a non-existing module Foo.
+    // Nothing should be installed.
+    \Drupal::state()->set('module_test.dependency', 'missing dependency');
+
+    try {
+      Recipe::createFromDirectory('core/tests/fixtures/recipes/missing_extensions');
+      $this->fail('Expected exception not thrown');
+    }
+    catch (RecipeMissingExtensionsException $e) {
+      $this->assertSame(['does_not_exist_one', 'does_not_exist_two', 'foo'], $e->extensions);
+    }
+  }
+
+  public function testPreExistingDifferentConfiguration(): void {
+    // Install the node module, its dependencies and configuration.
+    $this->container->get('module_installer')->install(['node']);
+    $this->assertFalse($this->config('node.settings')->get('use_admin_theme'), 'The node.settings:use_admin_theme is set to FALSE');
+
+    try {
+      Recipe::createFromDirectory('core/tests/fixtures/recipes/install_node_with_config');
+      $this->fail('Expected exception not thrown');
+    }
+    catch (RecipePreExistingConfigException $e) {
+      $this->assertSame("The configuration 'node.settings' exists already and does not match the recipe's configuration", $e->getMessage());
+      $this->assertSame('node.settings', $e->configName);
+    }
+  }
+
+  public function testPreExistingMatchingConfiguration(): void {
+    // Install the node module, its dependencies and configuration.
+    $this->container->get('module_installer')->install(['node']);
+    // Change the config to match the recipe's config to prevent the exception
+    // being thrown.
+    $this->config('node.settings')->set('use_admin_theme', TRUE)->save();
+
+    $recipe = Recipe::createFromDirectory('core/tests/fixtures/recipes/install_node_with_config');
+    $this->assertSame('core/tests/fixtures/recipes/install_node_with_config/config', $recipe->config->recipeConfigDirectory);
+  }
+
+  public function testRecipeIncludeMissing(): void {
+    try {
+      Recipe::createFromDirectory('core/tests/fixtures/recipes/recipe_include_missing');
+    }
+    catch (UnknownRecipeException $e) {
+      $this->assertSame('does_not_exist', $e->recipe);
+      $this->assertSame(['core/tests/fixtures/recipes'], $e->searchPaths);
+      $this->assertSame('Can not find the does_not_exist recipe, search paths: core/tests/fixtures/recipes', $e->getMessage());
+    }
+  }
+
+}
diff --git a/core/tests/Drupal/KernelTests/Core/Recipe/WildcardConfigActionsTest.php b/core/tests/Drupal/KernelTests/Core/Recipe/WildcardConfigActionsTest.php
new file mode 100644
index 0000000000..760f538fd3
--- /dev/null
+++ b/core/tests/Drupal/KernelTests/Core/Recipe/WildcardConfigActionsTest.php
@@ -0,0 +1,141 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\KernelTests\Core\Recipe;
+
+use Drupal\Core\Config\Action\ConfigActionException;
+use Drupal\Core\Entity\EntityTypeManagerInterface;
+use Drupal\Core\Recipe\Recipe;
+use Drupal\Core\Recipe\RecipeRunner;
+use Drupal\entity_test\Entity\EntityTestBundle;
+use Drupal\field\Entity\FieldConfig;
+use Drupal\field\Entity\FieldStorageConfig;
+use Drupal\KernelTests\KernelTestBase;
+use Drupal\Tests\node\Traits\ContentTypeCreationTrait;
+
+/**
+ * Tests config actions targeting multiple entities using wildcards.
+ *
+ * @group Recipe
+ */
+class WildcardConfigActionsTest extends KernelTestBase {
+
+  use ContentTypeCreationTrait;
+
+  /**
+   * {@inheritdoc}
+   */
+  protected static $modules = [
+    'entity_test',
+    'field',
+    'node',
+    'system',
+    'text',
+    'user',
+  ];
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function setUp(): void {
+    parent::setUp();
+    $this->installConfig('node');
+
+    $this->createContentType(['type' => 'one']);
+    $this->createContentType(['type' => 'two']);
+
+    EntityTestBundle::create(['id' => 'one'])->save();
+    EntityTestBundle::create(['id' => 'two'])->save();
+
+    $field_storage = FieldStorageConfig::create([
+      'entity_type' => 'entity_test_with_bundle',
+      'field_name' => 'field_test',
+      'type' => 'boolean',
+    ]);
+    $field_storage->save();
+    FieldConfig::create(['field_storage' => $field_storage, 'bundle' => 'one'])
+      ->save();
+    FieldConfig::create(['field_storage' => $field_storage, 'bundle' => 'two'])
+      ->save();
+
+    $field_storage = FieldStorageConfig::create([
+      'entity_type' => 'node',
+      'field_name' => 'field_test',
+      'type' => 'boolean',
+    ]);
+    $field_storage->save();
+    FieldConfig::create(['field_storage' => $field_storage, 'bundle' => 'one'])
+      ->save();
+    FieldConfig::create(['field_storage' => $field_storage, 'bundle' => 'two'])
+      ->save();
+  }
+
+  /**
+   * Tests targeting multiple config entities for an action, using wildcards.
+   *
+   * @param string $expression
+   *   The expression the recipe will use to target multiple config entities.
+   * @param string[] $expected_changed_entities
+   *   The IDs of the config entities that we expect the recipe to change.
+   *
+   * @testWith ["field.field.node.one.*", ["node.one.body", "node.one.field_test"]]
+   *   ["field.field.node.*.body", ["node.one.body", "node.two.body"]]
+   *   ["field.field.*.one.field_test", ["entity_test_with_bundle.one.field_test", "node.one.field_test"]]
+   *   ["field.field.node.*.*", ["node.one.body", "node.one.field_test", "node.two.body", "node.two.field_test"]]
+   *   ["field.field.*.one.*", ["entity_test_with_bundle.one.field_test", "node.one.field_test", "node.one.body"]]
+   *   ["field.field.*.*.field_test", ["entity_test_with_bundle.one.field_test", "entity_test_with_bundle.two.field_test", "node.one.field_test", "node.two.field_test"]]
+   *   ["field.field.*.*.*", ["entity_test_with_bundle.one.field_test", "entity_test_with_bundle.two.field_test", "node.one.field_test", "node.two.field_test", "node.one.body", "node.two.body"]]
+   */
+  public function testTargetEntitiesByWildcards(string $expression, array $expected_changed_entities): void {
+    $contents = <<<YAML
+name: 'Wildcards!'
+config:
+  actions:
+    $expression:
+      setLabel: 'Changed by config action'
+YAML;
+
+    $dir = uniqid('public://');
+    mkdir($dir);
+    file_put_contents($dir . '/recipe.yml', $contents);
+    $recipe = Recipe::createFromDirectory($dir);
+    RecipeRunner::processRecipe($recipe);
+
+    $changed = $this->container->get(EntityTypeManagerInterface::class)
+      ->getStorage('field_config')
+      ->getQuery()
+      ->condition('label', 'Changed by config action')
+      ->execute();
+    sort($expected_changed_entities);
+    sort($changed);
+    $this->assertSame($expected_changed_entities, array_values($changed));
+  }
+
+  /**
+   * Tests that an invalid wildcard expression will raise an error.
+   *
+   * @testWith ["field.*.node.one.*", "No installed config entity type uses the prefix in the expression 'field.*.node.one.*'. Either there is a typo in the expression or this recipe should install an additional module or depend on another recipe."]
+   *   ["field.field.node.*.body/", " could not be parsed."]
+   */
+  public function testInvalidExpression(string $expression, string $expected_exception_message): void {
+    $contents = <<<YAML
+name: 'Wildcards gone wild...'
+config:
+  actions:
+    $expression:
+      simple_config_update:
+        label: 'Changed by config action'
+YAML;
+
+    $dir = uniqid('public://');
+    mkdir($dir);
+    file_put_contents($dir . '/recipe.yml', $contents);
+    $recipe = Recipe::createFromDirectory($dir);
+
+    $this->expectException(ConfigActionException::class);
+    $this->expectExceptionMessage($expected_exception_message);
+    RecipeRunner::processRecipe($recipe);
+  }
+
+}
diff --git a/core/tests/Drupal/Tests/Core/Config/Checkpoint/CheckpointStorageTest.php b/core/tests/Drupal/Tests/Core/Config/Checkpoint/CheckpointStorageTest.php
new file mode 100644
index 0000000000..e79c307e5e
--- /dev/null
+++ b/core/tests/Drupal/Tests/Core/Config/Checkpoint/CheckpointStorageTest.php
@@ -0,0 +1,294 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\Tests\Core\Config\Checkpoint;
+
+use Drupal\Component\Datetime\Time;
+use Drupal\Core\Config\Checkpoint\Checkpoint;
+use Drupal\Core\Config\Checkpoint\LinearHistory;
+use Drupal\Core\Config\Checkpoint\CheckpointStorage;
+use Drupal\Core\Config\Config;
+use Drupal\Core\Config\ConfigCrudEvent;
+use Drupal\Core\Config\MemoryStorage;
+use Drupal\Core\Config\StorageCopyTrait;
+use Drupal\Core\Config\StorageInterface;
+use Drupal\Core\KeyValueStore\KeyValueMemoryFactory;
+use Drupal\Core\State\State;
+use Drupal\Tests\UnitTestCase;
+use Drupal\TestTools\Random;
+
+/**
+ * @coversDefaultClass \Drupal\Core\Config\Checkpoint\CheckpointStorage
+ * @group Config
+ */
+class CheckpointStorageTest extends UnitTestCase {
+
+  use StorageCopyTrait;
+
+  /**
+   * The memory storage containing the data.
+   *
+   * @var \Drupal\Core\Config\MemoryStorage
+   */
+  protected MemoryStorage $memory;
+
+  /**
+   * The checkpoint storage under test.
+   *
+   * @var \Drupal\Core\Config\Checkpoint\CheckpointStorage
+   */
+  protected CheckpointStorage $storage;
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function setUp(): void {
+    parent::setUp();
+
+    // Set up a memory storage we can manipulate to set fixtures.
+    $this->memory = new MemoryStorage();
+    $keyValueMemoryFactory = new KeyValueMemoryFactory();
+    $state = new State($keyValueMemoryFactory);
+    $time = new Time();
+    $checkpoints = new LinearHistory($state, $time);
+    $this->storage = new CheckpointStorage($this->memory, $checkpoints, $keyValueMemoryFactory);
+  }
+
+  /**
+   * @covers ::checkpoint
+   * @covers \Drupal\Core\Config\Checkpoint\Checkpoint
+   */
+  public function testCheckpointCreation(): void {
+    $checkpoint = $this->storage->checkpoint('Test');
+    $this->assertInstanceOf(Checkpoint::class, $checkpoint);
+    $this->assertSame('Test', $checkpoint->label);
+
+    $checkpoint2 = $this->storage->checkpoint('This will not make a checkpoint because nothing has changed');
+    $this->assertSame($checkpoint2, $checkpoint);
+    $config = $this->prophesize(Config::class);
+    $config->getName()->willReturn('test.config');
+    $config->getOriginal('', FALSE)->willReturn([]);
+    $config->getRawData()->willReturn(['foo' => 'bar']);
+    $config->getStorage()->willReturn($this->storage);
+    $event = new ConfigCrudEvent($config->reveal());
+    $this->storage->onConfigSaveAndDelete($event);
+
+    $checkpoint3 = $this->storage->checkpoint('Created test.config');
+    $this->assertNotSame($checkpoint3, $checkpoint);
+    $this->assertSame('Created test.config', $checkpoint3->label);
+
+    $checkpoint4 = $this->storage->checkpoint('This will not create a checkpoint either');
+    $this->assertSame($checkpoint4, $checkpoint3);
+
+    // Simulate a save with no change.
+    $config = $this->prophesize(Config::class);
+    $config->getName()->willReturn('test.config');
+    $config->getOriginal('', FALSE)->willReturn(['foo' => 'bar']);
+    $config->getRawData()->willReturn(['foo' => 'bar']);
+    $config->getStorage()->willReturn($this->storage);
+    $event = new ConfigCrudEvent($config->reveal());
+    $this->storage->onConfigSaveAndDelete($event);
+
+    $checkpoint5 = $this->storage->checkpoint('Save with no change');
+    $this->assertSame($checkpoint5, $checkpoint3);
+
+    // Create collection and ensure that checkpoints are kept in sync.
+    $collection = $this->storage->createCollection('test');
+    $config = $this->prophesize(Config::class);
+    $config->getName()->willReturn('test.config');
+    $config->getOriginal('', FALSE)->willReturn(['foo' => 'bar']);
+    $config->getRawData()->willReturn(['foo' => 'collection_bar']);
+    $config->getStorage()->willReturn($collection);
+    $event = new ConfigCrudEvent($config->reveal());
+    $collection->onConfigSaveAndDelete($event);
+
+    $checkpoint6 = $this->storage->checkpoint('Save in collection');
+    $this->assertNotSame($checkpoint6, $checkpoint3);
+    $this->assertSame($collection->checkpoint('Calling checkpoint on collection'), $checkpoint6);
+  }
+
+  /**
+   * @covers ::exists
+   * @covers ::read
+   * @covers ::readMultiple
+   * @covers ::listAll
+   *
+   * @dataProvider readMethodsProvider
+   */
+  public function testReadOperations(string $method, array $arguments, array $fixture): void {
+    // Create a checkpoint so the checkpoint storage can be read from.
+    $this->storage->checkpoint('');
+    $this->setRandomFixtureConfig($fixture);
+
+    $expected = call_user_func_array([$this->memory, $method], $arguments);
+    $actual = call_user_func_array([$this->storage, $method], $arguments);
+    $this->assertEquals($expected, $actual);
+  }
+
+  /**
+   * Provide the methods that work transparently.
+   *
+   * @return array
+   *   The data.
+   */
+  public function readMethodsProvider(): array {
+    $fixture = [
+      StorageInterface::DEFAULT_COLLECTION => ['config.a', 'config.b', 'other.a'],
+    ];
+
+    $data = [];
+    $data[] = ['exists', ['config.a'], $fixture];
+    $data[] = ['exists', ['not.existing'], $fixture];
+    $data[] = ['read', ['config.a'], $fixture];
+    $data[] = ['read', ['not.existing'], $fixture];
+    $data[] = ['readMultiple', [['config.a', 'config.b', 'not']], $fixture];
+    $data[] = ['listAll', [''], $fixture];
+    $data[] = ['listAll', ['config'], $fixture];
+    $data[] = ['listAll', ['none'], $fixture];
+
+    return $data;
+  }
+
+  /**
+   * @covers ::write
+   * @covers ::delete
+   * @covers ::rename
+   * @covers ::deleteAll
+   *
+   * @dataProvider writeMethodsProvider
+   */
+  public function testWriteOperations(string $method, array $arguments, array $fixture): void {
+    $this->setRandomFixtureConfig($fixture);
+
+    // Create an independent memory storage as a backup.
+    $backup = new MemoryStorage();
+    static::replaceStorageContents($this->memory, $backup);
+
+    try {
+      call_user_func_array([$this->storage, $method], $arguments);
+      $this->fail("exception not thrown");
+    }
+    catch (\BadMethodCallException $exception) {
+      $this->assertEquals(CheckpointStorage::class . '::' . $method . ' is not allowed on a CheckpointStorage', $exception->getMessage());
+    }
+
+    // Assert that the memory storage has not been altered.
+    $this->assertEquals($backup, $this->memory);
+  }
+
+  /**
+   * Provide the methods that throw an exception.
+   *
+   * @return array
+   *   The data
+   */
+  public static function writeMethodsProvider(): array {
+    $fixture = [
+      StorageInterface::DEFAULT_COLLECTION => ['config.a', 'config.b'],
+    ];
+
+    $data = [];
+    $data[] = ['write', ['config.a', (array) Random::getGenerator()->object()], $fixture];
+    $data[] = ['write', [Random::MachineName(), (array) Random::getGenerator()->object()], $fixture];
+    $data[] = ['delete', ['config.a'], $fixture];
+    $data[] = ['delete', [Random::MachineName()], $fixture];
+    $data[] = ['rename', ['config.a', 'config.b'], $fixture];
+    $data[] = ['rename', ['config.a', Random::MachineName()], $fixture];
+    $data[] = ['rename', [Random::MachineName(), Random::MachineName()], $fixture];
+    $data[] = ['deleteAll', [''], $fixture];
+    $data[] = ['deleteAll', ['config'], $fixture];
+    $data[] = ['deleteAll', ['other'], $fixture];
+
+    return $data;
+  }
+
+  /**
+   * @covers ::getAllCollectionNames
+   * @covers ::getCollectionName
+   * @covers ::createCollection
+   */
+  public function testCollections(): void {
+    $ref_readFromCheckpoint = new \ReflectionProperty($this->storage, 'readFromCheckpoint');
+
+    // Create some checkpoints so the checkpoint storage can be read from.
+    $checkpoint1 = $this->storage->checkpoint('1');
+    $config = $this->prophesize(Config::class);
+    $config->getName()->willReturn('test.config');
+    $config->getOriginal('', FALSE)->willReturn([]);
+    $config->getRawData()->willReturn(['foo' => 'bar']);
+    $config->getStorage()->willReturn($this->storage);
+    $event = new ConfigCrudEvent($config->reveal());
+    $this->storage->onConfigSaveAndDelete($event);
+    $checkpoint2 = $this->storage->checkpoint('2');
+
+    $fixture = [
+      StorageInterface::DEFAULT_COLLECTION => [$this->randomMachineName()],
+      'A' => [$this->randomMachineName()],
+      'B' => [$this->randomMachineName()],
+      'C' => [$this->randomMachineName()],
+    ];
+    $this->setRandomFixtureConfig($fixture);
+
+    $this->assertEquals(['A', 'B', 'C'], $this->storage->getAllCollectionNames());
+    foreach (array_keys($fixture) as $collection) {
+      $storage = $this->storage->createCollection($collection);
+      // Assert that the collection storage is still a checkpoint storage.
+      $this->assertInstanceOf(CheckpointStorage::class, $storage);
+      $this->assertEquals($collection, $storage->getCollectionName());
+
+      // Ensure that the
+      // \Drupal\Core\Config\Checkpoint\CheckpointStorage::$readFromCheckpoint
+      // property is kept in sync.
+      $this->storage->setCheckpointToReadFrom($checkpoint2);
+      $this->assertSame($checkpoint2->id, $ref_readFromCheckpoint->getValue($storage->createCollection($collection))?->id);
+      if (isset($previous_collection)) {
+        $previous_collection->setCheckpointToReadFrom($checkpoint1);
+        $this->assertSame($checkpoint1->id, $ref_readFromCheckpoint->getValue($storage->createCollection($collection))?->id);
+        $this->assertSame($checkpoint1->id, $ref_readFromCheckpoint->getValue($this->storage->createCollection($collection))?->id);
+      }
+
+      // Save the storage in a variable so we can test use
+      // setCheckpointToReadFrom() on it.
+      $previous_collection = $storage;
+    }
+  }
+
+  /**
+   * @covers ::encode
+   * @covers ::decode
+   */
+  public function testEncodeDecode(): void {
+    $array = (array) $this->getRandomGenerator()->object();
+    $string = $this->getRandomGenerator()->string();
+
+    // Assert reversibility of encoding and decoding.
+    $this->assertEquals($array, $this->storage->decode($this->storage->encode($array)));
+    $this->assertEquals($string, $this->storage->encode($this->storage->decode($string)));
+    // Assert same results as the decorated storage.
+    $this->assertEquals($this->memory->encode($array), $this->storage->encode($array));
+    $this->assertEquals($this->memory->decode($string), $this->storage->decode($string));
+  }
+
+  /**
+   * Generate random config in the memory storage.
+   *
+   * @param array $config
+   *   The config keys, keyed by the collection.
+   */
+  protected function setRandomFixtureConfig(array $config): void {
+    // Erase previous fixture.
+    foreach (array_merge([StorageInterface::DEFAULT_COLLECTION], $this->memory->getAllCollectionNames()) as $collection) {
+      $this->memory->createCollection($collection)->deleteAll();
+    }
+
+    foreach ($config as $collection => $keys) {
+      $storage = $this->memory->createCollection($collection);
+      foreach ($keys as $key) {
+        // Create some random config.
+        $storage->write($key, (array) $this->getRandomGenerator()->object());
+      }
+    }
+  }
+
+}
diff --git a/core/tests/Drupal/Tests/Core/Config/Checkpoint/LinearHistoryTest.php b/core/tests/Drupal/Tests/Core/Config/Checkpoint/LinearHistoryTest.php
new file mode 100644
index 0000000000..1a3ee6cd7c
--- /dev/null
+++ b/core/tests/Drupal/Tests/Core/Config/Checkpoint/LinearHistoryTest.php
@@ -0,0 +1,190 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\Tests\Core\Config\Checkpoint;
+
+use Drupal\Component\Datetime\TimeInterface;
+use Drupal\Component\Render\FormattableMarkup;
+use Drupal\Core\Config\Checkpoint\Checkpoint;
+use Drupal\Core\Config\Checkpoint\CheckpointExistsException;
+use Drupal\Core\Config\Checkpoint\UnknownCheckpointException;
+use Drupal\Core\Config\Checkpoint\LinearHistory;
+use Drupal\Core\State\StateInterface;
+use Drupal\Tests\UnitTestCase;
+use Prophecy\Argument;
+
+/**
+ * @coversDefaultClass \Drupal\Core\Config\Checkpoint\LinearHistory
+ * @group Config
+ */
+class LinearHistoryTest extends UnitTestCase {
+
+  /**
+   * The key used store of all the checkpoint names in state.
+   *
+   * @see \Drupal\Core\Config\Checkpoint\Checkpoints::CHECKPOINT_KEY
+   */
+  private const CHECKPOINT_KEY = 'config.checkpoints';
+
+  /**
+   * @covers ::add
+   * @covers ::count
+   * @covers ::getActiveCheckpoint
+   * @covers \Drupal\Core\Config\Checkpoint\Checkpoint
+   */
+  public function testAdd(): void {
+    $state = $this->prophesize(StateInterface::class);
+    $state->get(self::CHECKPOINT_KEY, [])->willReturn([]);
+    $state->set(self::CHECKPOINT_KEY, Argument::any())->willReturn(NULL);
+    $time = $this->prophesize(TimeInterface::class);
+    $time->getCurrentTime()->willReturn(1701539520, 1701539994);
+    $checkpoints = new LinearHistory($state->reveal(), $time->reveal());
+
+    $this->assertCount(0, $checkpoints);
+    $this->assertNull($checkpoints->getActiveCheckpoint());
+
+    $checkpoint = $checkpoints->add('hash1', 'Label');
+
+    $this->assertSame('hash1', $checkpoint->id);
+    $this->assertSame('Label', $checkpoint->label);
+    $this->assertNull($checkpoint->parent);
+    $this->assertSame(1701539520, $checkpoint->timestamp);
+
+    $this->assertCount(1, $checkpoints);
+    $this->assertSame('hash1', $checkpoints->getActiveCheckpoint()?->id);
+
+    // Test that on the second call to add the ancestor is set correctly.
+    $checkpoint2 = $checkpoints->add('hash2', new FormattableMarkup('Another label', []));
+    $this->assertSame('hash2', $checkpoint2->id);
+    $this->assertSame('Another label', (string) $checkpoint2->label);
+    $this->assertSame($checkpoint->id, $checkpoint2->parent);
+    $this->assertSame(1701539994, $checkpoint2->timestamp);
+
+    $this->assertCount(2, $checkpoints);
+    $this->assertSame('hash2', $checkpoints->getActiveCheckpoint()?->id);
+
+    // Test that the checkpoints object can be iterated over.
+    $i = 0;
+    foreach ($checkpoints as $value) {
+      $i++;
+      $this->assertInstanceOf(Checkpoint::class, $value);
+      $this->assertSame('hash' . $i, $value->id);
+    }
+  }
+
+  /**
+   * @covers ::add
+   */
+  public function testAddException(): void {
+    $state = $this->prophesize(StateInterface::class);
+    $state->get(self::CHECKPOINT_KEY, [])->willReturn([]);
+    $state->set(self::CHECKPOINT_KEY, Argument::any())->willReturn(NULL);
+    $time = $this->prophesize(TimeInterface::class);
+    $time->getCurrentTime()->willReturn(1701539520, 1701539994);
+    $checkpoints = new LinearHistory($state->reveal(), $time->reveal());
+    $checkpoints->add('hash1', 'Label');
+    // Add another checkpoint with the same ID and an exception should be
+    // triggered.
+    $this->expectException(CheckpointExistsException::class);
+    $this->expectExceptionMessage('Cannot create a checkpoint with the ID "hash1" as it already exists');
+    $checkpoints->add('hash1', 'Label');
+  }
+
+  /**
+   * @covers ::delete
+   */
+  public function testDeleteAll(): void {
+    $state = $this->prophesize(StateInterface::class);
+    $state->get(self::CHECKPOINT_KEY, [])->willReturn([
+      'hash1' => new Checkpoint('hash1', 'One', 1701539510, NULL),
+      'hash2' => new Checkpoint('hash2', 'Two', 1701539520, 'hash1'),
+      'hash3' => new Checkpoint('hash3', 'Three', 1701539530, 'hash2'),
+    ]);
+    $state->delete(self::CHECKPOINT_KEY)->willReturn();
+    $time = $this->prophesize(TimeInterface::class);
+    $checkpoints = new LinearHistory($state->reveal(), $time->reveal());
+
+    $this->assertCount(3, $checkpoints);
+    $this->assertSame('hash3', $checkpoints->getActiveCheckpoint()?->id);
+    $checkpoints->deleteAll();
+    $this->assertCount(0, $checkpoints);
+    $this->assertNull($checkpoints->getActiveCheckpoint());
+  }
+
+  /**
+   * @covers ::delete
+   */
+  public function testDelete(): void {
+    $state = $this->prophesize(StateInterface::class);
+    $test_data = [
+      'hash1' => new Checkpoint('hash1', 'One', 1701539510, NULL),
+      'hash2' => new Checkpoint('hash2', 'Two', 1701539520, 'hash1'),
+      'hash3' => new Checkpoint('hash3', 'Three', 1701539530, 'hash2'),
+    ];
+    $state->get(self::CHECKPOINT_KEY, [])->willReturn($test_data);
+    unset($test_data['hash1'], $test_data['hash2']);
+    $state->set(self::CHECKPOINT_KEY, $test_data)->willReturn();
+    $time = $this->prophesize(TimeInterface::class);
+    $checkpoints = new LinearHistory($state->reveal(), $time->reveal());
+
+    $this->assertCount(3, $checkpoints);
+    $this->assertSame('hash3', $checkpoints->getActiveCheckpoint()?->id);
+    $checkpoints->delete('hash2');
+    $this->assertCount(1, $checkpoints);
+    $this->assertSame('hash3', $checkpoints->getActiveCheckpoint()?->id);
+  }
+
+  /**
+   * @covers ::delete
+   */
+  public function testDeleteException(): void {
+    $state = $this->prophesize(StateInterface::class);
+    $state->get(self::CHECKPOINT_KEY, [])->willReturn([]);
+    $time = $this->prophesize(TimeInterface::class);
+    $checkpoints = new LinearHistory($state->reveal(), $time->reveal());
+
+    $this->expectException(UnknownCheckpointException::class);
+    $this->expectExceptionMessage('Cannot delete a checkpoint with the ID "foo" as it does not exist');
+
+    $checkpoints->delete('foo');
+  }
+
+  /**
+   * @covers ::getParents
+   */
+  public function testGetParents(): void {
+    $state = $this->prophesize(StateInterface::class);
+    $test_data = [
+      'hash1' => new Checkpoint('hash1', 'One', 1701539510, NULL),
+      'hash2' => new Checkpoint('hash2', 'Two', 1701539520, 'hash1'),
+      'hash3' => new Checkpoint('hash3', 'Three', 1701539530, 'hash2'),
+    ];
+    $state->get(self::CHECKPOINT_KEY, [])->willReturn($test_data);
+    $time = $this->prophesize(TimeInterface::class);
+    $checkpoints = new LinearHistory($state->reveal(), $time->reveal());
+
+    $this->assertSame(['hash2' => $test_data['hash2'], 'hash1' => $test_data['hash1']], iterator_to_array($checkpoints->getParents('hash3')));
+    $this->assertSame(['hash1' => $test_data['hash1']], iterator_to_array($checkpoints->getParents('hash2')));
+    $this->assertSame([], iterator_to_array($checkpoints->getParents('hash1')));
+  }
+
+  /**
+   * @covers ::getParents
+   */
+  public function testGetParentsException(): void {
+    $state = $this->prophesize(StateInterface::class);
+    $test_data = [
+      'hash1' => new Checkpoint('hash1', 'One', 1701539510, NULL),
+      'hash2' => new Checkpoint('hash2', 'Two', 1701539520, 'hash1'),
+    ];
+    $state->get(self::CHECKPOINT_KEY, [])->willReturn($test_data);
+    $time = $this->prophesize(TimeInterface::class);
+    $checkpoints = new LinearHistory($state->reveal(), $time->reveal());
+
+    $this->expectException(UnknownCheckpointException::class);
+    $this->expectExceptionMessage('The checkpoint "hash3" does not exist');
+    iterator_to_array($checkpoints->getParents('hash3'));
+  }
+
+}
diff --git a/core/tests/Drupal/Tests/Core/Recipe/RecipeConfigStorageWrapperTest.php b/core/tests/Drupal/Tests/Core/Recipe/RecipeConfigStorageWrapperTest.php
new file mode 100644
index 0000000000..b74c14d8b4
--- /dev/null
+++ b/core/tests/Drupal/Tests/Core/Recipe/RecipeConfigStorageWrapperTest.php
@@ -0,0 +1,324 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\Tests\Core\Recipe;
+
+use Drupal\Core\Config\MemoryStorage;
+use Drupal\Core\Config\NullStorage;
+use Drupal\Core\Config\StorageInterface;
+use Drupal\Core\Recipe\RecipeConfigStorageWrapper;
+use Drupal\Tests\UnitTestCase;
+
+/**
+ * @coversDefaultClass \Drupal\Core\Recipe\RecipeConfigStorageWrapper
+ * @group Recipe
+ */
+class RecipeConfigStorageWrapperTest extends UnitTestCase {
+
+  /**
+   * Validate that an empty set of storage backends returns null storage.
+   */
+  public function testNullStorage(): void {
+    $this->assertInstanceOf(
+      NullStorage::class,
+      RecipeConfigStorageWrapper::createStorageFromArray([])
+    );
+  }
+
+  /**
+   * Validate that a single storage returns exactly the same instance.
+   */
+  public function testSingleStorage(): void {
+    $storages = [new NullStorage()];
+    $this->assertSame(
+      $storages[0],
+      RecipeConfigStorageWrapper::createStorageFromArray($storages)
+    );
+  }
+
+  /**
+   * Validate that multiple storages return underlying values correctly.
+   */
+  public function testMultipleStorages(): void {
+    $a = new MemoryStorage();
+    $a->write('a_key', ['a_data_first']);
+    $b = new MemoryStorage();
+
+    // Add a conflicting key so that we can test the first value is returned.
+    $b->write('a_key', ['a_data_second']);
+    $b->write('b_key', ['b_data']);
+
+    // We test with a third storage as well since only two storages can be done
+    // via the constructor alone.
+    $c = new MemoryStorage();
+    $c->write('c_key', ['c_data']);
+
+    $storages = [$a, $b, $c];
+    $wrapped = RecipeConfigStorageWrapper::createStorageFromArray($storages);
+
+    $this->assertSame($a->read('a_key'), $wrapped->read('a_key'));
+    $this->assertNotEquals($b->read('a_key'), $wrapped->read('a_key'));
+    $this->assertSame($b->read('b_key'), $wrapped->read('b_key'));
+    $this->assertSame($c->read('c_key'), $wrapped->read('c_key'));
+  }
+
+  /**
+   * Validate that the first storage checks existence first.
+   */
+  public function testLeftSideExists(): void {
+    $a = $this->createMock(StorageInterface::class);
+    $a->expects($this->once())->method('exists')->with('a_key')
+      ->willReturn(TRUE);
+    $b = $this->createMock(StorageInterface::class);
+    $b->expects($this->never())->method('exists');
+
+    $storage = new RecipeConfigStorageWrapper($a, $b);
+    $this->assertTrue($storage->exists('a_key'));
+  }
+
+  /**
+   * Validate that we fall back to the second storage.
+   */
+  public function testRightSideExists(): void {
+    [$a, $b] = $this->generateStorages(TRUE);
+
+    $storage = new RecipeConfigStorageWrapper($a, $b);
+    $storage->exists('a_key');
+  }
+
+  /**
+   * Validate FALSE when neither storage contains a key.
+   */
+  public function testNotExists(): void {
+    [$a, $b] = $this->generateStorages(FALSE);
+
+    $storage = new RecipeConfigStorageWrapper($a, $b);
+    $this->assertFalse($storage->exists('a_key'));
+  }
+
+  /**
+   * Validate that we read from storage A first.
+   */
+  public function testReadFromA(): void {
+    $a = $this->createMock(StorageInterface::class);
+    $value = ['a_value'];
+    $a->expects($this->once())->method('read')->with('a_key')
+      ->willReturn($value);
+    $b = $this->createMock(StorageInterface::class);
+    $b->expects($this->never())->method('read');
+
+    $storage = new RecipeConfigStorageWrapper($a, $b);
+    $this->assertSame($value, $storage->read('a_key'));
+  }
+
+  /**
+   * Validate that we read from storage B second.
+   */
+  public function testReadFromB(): void {
+    $a = $this->createMock(StorageInterface::class);
+    $a->expects($this->once())->method('read')->with('a_key')
+      ->willReturn(FALSE);
+    $b = $this->createMock(StorageInterface::class);
+    $value = ['a_value'];
+    $b->expects($this->once())->method('read')->with('a_key')
+      ->willReturn($value);
+
+    $storage = new RecipeConfigStorageWrapper($a, $b);
+    $this->assertSame($value, $storage->read('a_key'));
+  }
+
+  /**
+   * Validate when neither storage can read a value.
+   */
+  public function testReadFails(): void {
+    $a = $this->createMock(StorageInterface::class);
+    $a->expects($this->once())->method('read')->with('a_key')
+      ->willReturn(FALSE);
+    $b = $this->createMock(StorageInterface::class);
+    $b->expects($this->once())->method('read')->with('a_key')
+      ->willReturn(FALSE);
+
+    $storage = new RecipeConfigStorageWrapper($a, $b);
+    $this->assertFalse($storage->read('a_key'));
+  }
+
+  /**
+   * Test reading multiple values.
+   */
+  public function testReadMultiple(): void {
+    $a = $this->createMock(StorageInterface::class);
+    $a->expects($this->once())->method('readMultiple')->with(['a_key', 'b_key'])
+      ->willReturn(['a_key' => ['a_value']]);
+    $b = $this->createMock(StorageInterface::class);
+    $b->expects($this->once())->method('readMultiple')->with(['a_key', 'b_key'])
+      ->willReturn(['b_key' => ['b_value']]);
+
+    $storage = new RecipeConfigStorageWrapper($a, $b);
+    $this->assertEquals([
+      'a_key' => ['a_value'],
+      'b_key' => ['b_value'],
+    ], $storage->readMultiple(['a_key', 'b_key']));
+  }
+
+  /**
+   * Test that storage A has precedence over storage B.
+   */
+  public function testReadMultipleStorageA(): void {
+    $a = $this->createMock(StorageInterface::class);
+    $a->expects($this->once())->method('readMultiple')->with(['a_key', 'b_key'])
+      ->willReturn(['a_key' => ['a_value']]);
+    $b = $this->createMock(StorageInterface::class);
+    $b->expects($this->once())->method('readMultiple')->with(['a_key', 'b_key'])
+      ->willReturn(['a_key' => ['a_conflicting_value'], 'b_key' => ['b_value']]);
+
+    $storage = new RecipeConfigStorageWrapper($a, $b);
+    $this->assertEquals([
+      'a_key' => ['a_value'],
+      'b_key' => ['b_value'],
+    ], $storage->readMultiple(['a_key', 'b_key']));
+  }
+
+  /**
+   * Test methods that are unsupported.
+   *
+   * @param string $method
+   *   The method to call.
+   * @param array $args
+   *   The arguments to pass to the method.
+   *
+   * @dataProvider unsupportedMethods
+   */
+  public function testUnsupportedMethods(string $method, ...$args): void {
+    $this->expectException(\BadMethodCallException::class);
+    $storage = new RecipeConfigStorageWrapper(new NullStorage(), new NullStorage());
+    $storage->{$method}(...$args);
+  }
+
+  /**
+   * Test that we only use storage A's encode method.
+   */
+  public function testEncode(): void {
+    $a = $this->createMock(StorageInterface::class);
+    $data = 'value';
+    $a->expects($this->once())->method('encode')->with([$data])
+      ->willReturn($data);
+    $b = $this->createMock(StorageInterface::class);
+    $b->expects($this->never())->method('encode');
+    $storage = new RecipeConfigStorageWrapper($a, $b);
+    $this->assertSame($data, $storage->encode([$data]));
+  }
+
+  /**
+   * Test that we only use storage A's decode method.
+   */
+  public function testDecode(): void {
+    $a = $this->createMock(StorageInterface::class);
+    $raw = 'value';
+    $a->expects($this->once())->method('decode')->with($raw)
+      ->willReturn([$raw]);
+    $b = $this->createMock(StorageInterface::class);
+    $b->expects($this->never())->method('decode');
+    $storage = new RecipeConfigStorageWrapper($a, $b);
+    $this->assertEquals([$raw], $storage->decode($raw));
+  }
+
+  /**
+   * Test that list all merges values and makes them unique.
+   */
+  public function testListAll(): void {
+    $a = $this->createMock(StorageInterface::class);
+    $a->method('listAll')->with('node.')
+      ->willReturn(['node.type']);
+    $b = $this->createMock(StorageInterface::class);
+    $b->method('listAll')->with('node.')
+      ->willReturn(['node.type', 'node.id']);
+    $storage = new RecipeConfigStorageWrapper($a, $b);
+    $this->assertEquals([
+      0 => 'node.type',
+      2 => 'node.id',
+    ], $storage->listAll('node.'));
+  }
+
+  /**
+   * Test creating a collection passes the name through to the child storages.
+   */
+  public function testCreateCollection(): void {
+    $collection_name = 'collection';
+    $a = $this->createMock(StorageInterface::class);
+    $b = $this->createMock(StorageInterface::class);
+    /** @var \PHPUnit\Framework\MockObject\MockObject $mock */
+    foreach ([$a, $b] as $mock) {
+      $mock->expects($this->once())->method('createCollection')
+        ->with($collection_name)->willReturn(new NullStorage($collection_name));
+    }
+    $storage = new RecipeConfigStorageWrapper($a, $b);
+    $new = $storage->createCollection($collection_name);
+    $this->assertInstanceOf(RecipeConfigStorageWrapper::class, $new);
+    $this->assertEquals($collection_name, $new->getCollectionName());
+    $this->assertNotEquals($storage, $new);
+  }
+
+  /**
+   * Test that we merge and return only unique collection names.
+   */
+  public function testGetAllCollectionNames(): void {
+    $a = $this->createMock(StorageInterface::class);
+    $a->expects($this->once())->method('getAllCollectionNames')
+      ->willReturn(['collection_1', 'collection_2']);
+    $b = $this->createMock(StorageInterface::class);
+    $b->expects($this->once())->method('getAllCollectionNames')
+      ->willReturn(['collection_3', 'collection_1', 'collection_2']);
+    $storage = new RecipeConfigStorageWrapper($a, $b);
+    $this->assertEquals([
+      'collection_1',
+      'collection_2',
+      'collection_3',
+    ], $storage->getAllCollectionNames());
+  }
+
+  /**
+   * Test the collection name is stored properly.
+   */
+  public function testGetCollection(): void {
+    $a = $this->createMock(StorageInterface::class);
+    $b = $this->createMock(StorageInterface::class);
+    $storage = new RecipeConfigStorageWrapper($a, $b, 'collection');
+    $this->assertEquals('collection', $storage->getCollectionName());
+  }
+
+  /**
+   * Generate two storages where the second storage should return a value.
+   *
+   * @param bool $b_return
+   *   The return value for storage $b's exist method.
+   *
+   * @return \Drupal\Core\Config\StorageInterface[]
+   *   An array of two mocked storages.
+   */
+  private function generateStorages(bool $b_return): array {
+    $a = $this->createMock(StorageInterface::class);
+    $a->expects($this->once())->method('exists')->with('a_key')
+      ->willReturn(FALSE);
+    $b = $this->createMock(StorageInterface::class);
+    $b->expects($this->once())->method('exists')->with('a_key')
+      ->willReturn($b_return);
+    return [$a, $b];
+  }
+
+  /**
+   * Data provider for methods that are unsupported.
+   *
+   * @return array
+   *   An array of method names w/ args to test the unsupported methods.
+   */
+  public function unsupportedMethods(): array {
+    return [
+      ['write', 'name', []],
+      ['delete', 'name'],
+      ['rename', 'old_name', 'new_name'],
+      ['deleteAll'],
+    ];
+  }
+
+}
diff --git a/core/tests/fixtures/recipes/base_theme_and_views/recipe.yml b/core/tests/fixtures/recipes/base_theme_and_views/recipe.yml
new file mode 100644
index 0000000000..6d9589f9c3
--- /dev/null
+++ b/core/tests/fixtures/recipes/base_theme_and_views/recipe.yml
@@ -0,0 +1,6 @@
+name: 'Base theme and views'
+type: 'Testing'
+install:
+  - test_subsubtheme
+  - node
+  - views
diff --git a/core/tests/fixtures/recipes/config_actions/recipe.yml b/core/tests/fixtures/recipes/config_actions/recipe.yml
new file mode 100644
index 0000000000..4e16eeb67b
--- /dev/null
+++ b/core/tests/fixtures/recipes/config_actions/recipe.yml
@@ -0,0 +1,13 @@
+name: 'Config actions'
+type: 'Testing'
+install:
+  - config_test
+config:
+  actions:
+    config_test.dynamic.recipe:
+      ensure_exists:
+        label: 'Created by recipe'
+      setProtectedProperty: 'Set by recipe'
+    config_test.system:
+      simple_config_update:
+        foo: 'not bar'
diff --git a/core/tests/fixtures/recipes/config_from_module/recipe.yml b/core/tests/fixtures/recipes/config_from_module/recipe.yml
new file mode 100644
index 0000000000..f88aa486c1
--- /dev/null
+++ b/core/tests/fixtures/recipes/config_from_module/recipe.yml
@@ -0,0 +1,9 @@
+name: 'Config from module'
+type: 'Testing'
+install:
+  - config_test
+config:
+  import:
+    config_test:
+      - config_test.dynamic.dotted.default
+      - config_test.dynamic.override
diff --git a/core/tests/fixtures/recipes/config_from_module_and_recipe/config/config_test.dynamic.dotted.default.yml b/core/tests/fixtures/recipes/config_from_module_and_recipe/config/config_test.dynamic.dotted.default.yml
new file mode 100644
index 0000000000..ce5eb672c3
--- /dev/null
+++ b/core/tests/fixtures/recipes/config_from_module_and_recipe/config/config_test.dynamic.dotted.default.yml
@@ -0,0 +1,6 @@
+id: dotted.default
+label: 'Provided by recipe'
+weight: 0
+protected_property: Default
+# Intentionally commented out to verify default status behavior.
+# status: 1
diff --git a/core/tests/fixtures/recipes/config_from_module_and_recipe/config/config_test.system.yml b/core/tests/fixtures/recipes/config_from_module_and_recipe/config/config_test.system.yml
new file mode 100644
index 0000000000..5aa1d937ae
--- /dev/null
+++ b/core/tests/fixtures/recipes/config_from_module_and_recipe/config/config_test.system.yml
@@ -0,0 +1,2 @@
+foo: bar
+404: foo
diff --git a/core/tests/fixtures/recipes/config_from_module_and_recipe/recipe.yml b/core/tests/fixtures/recipes/config_from_module_and_recipe/recipe.yml
new file mode 100644
index 0000000000..91b42de456
--- /dev/null
+++ b/core/tests/fixtures/recipes/config_from_module_and_recipe/recipe.yml
@@ -0,0 +1,12 @@
+name: 'Config from module and recipe'
+type: 'Testing'
+install:
+  - config_test
+  - tour
+  - tour_test
+config:
+  import:
+    config_test: '*'
+    tour_test:
+      - tour.tour.tour-test
+      - tour.tour.tour-test2
diff --git a/core/tests/fixtures/recipes/config_wildcard/recipe.yml b/core/tests/fixtures/recipes/config_wildcard/recipe.yml
new file mode 100644
index 0000000000..582f7aeb89
--- /dev/null
+++ b/core/tests/fixtures/recipes/config_wildcard/recipe.yml
@@ -0,0 +1,8 @@
+name: 'Config wildcard'
+type: 'Testing'
+install:
+  - config_test
+  - tour
+config:
+  import:
+    config_test: '*'
diff --git a/core/tests/fixtures/recipes/install_node_with_config/config/node.settings.yml b/core/tests/fixtures/recipes/install_node_with_config/config/node.settings.yml
new file mode 100644
index 0000000000..6cb95cbc42
--- /dev/null
+++ b/core/tests/fixtures/recipes/install_node_with_config/config/node.settings.yml
@@ -0,0 +1 @@
+use_admin_theme: true
diff --git a/core/tests/fixtures/recipes/install_node_with_config/config/node.type.test.yml b/core/tests/fixtures/recipes/install_node_with_config/config/node.type.test.yml
new file mode 100644
index 0000000000..567eb1bfe9
--- /dev/null
+++ b/core/tests/fixtures/recipes/install_node_with_config/config/node.type.test.yml
@@ -0,0 +1,9 @@
+langcode: en
+status: true
+name: 'Test content type'
+type: test
+description: 'Test content type from a recipe'
+help: ''
+new_revision: true
+preview_mode: 1
+display_submitted: true
diff --git a/core/tests/fixtures/recipes/install_node_with_config/recipe.yml b/core/tests/fixtures/recipes/install_node_with_config/recipe.yml
new file mode 100644
index 0000000000..e2fc243b52
--- /dev/null
+++ b/core/tests/fixtures/recipes/install_node_with_config/recipe.yml
@@ -0,0 +1,5 @@
+name: 'Install node with config'
+type: 'Content type'
+install:
+  - node
+  - drupal:text
diff --git a/core/tests/fixtures/recipes/install_two_modules/recipe.yml b/core/tests/fixtures/recipes/install_two_modules/recipe.yml
new file mode 100644
index 0000000000..ee57ca146d
--- /dev/null
+++ b/core/tests/fixtures/recipes/install_two_modules/recipe.yml
@@ -0,0 +1,5 @@
+name: 'Install two modules'
+type: 'Content type'
+install:
+  - node
+  - text
diff --git a/core/tests/fixtures/recipes/missing_extensions/recipe.yml b/core/tests/fixtures/recipes/missing_extensions/recipe.yml
new file mode 100644
index 0000000000..77c82fbeee
--- /dev/null
+++ b/core/tests/fixtures/recipes/missing_extensions/recipe.yml
@@ -0,0 +1,6 @@
+name: 'Missing extensions'
+type: 'Testing'
+install:
+  - does_not_exist_one
+  - does_not_exist_two
+  - dblog
diff --git a/core/tests/fixtures/recipes/no_extensions/recipe.yml b/core/tests/fixtures/recipes/no_extensions/recipe.yml
new file mode 100644
index 0000000000..b7d3aeb4f0
--- /dev/null
+++ b/core/tests/fixtures/recipes/no_extensions/recipe.yml
@@ -0,0 +1,3 @@
+name: 'No extensions'
+description: 'A recipe description'
+type: 'Testing'
diff --git a/core/tests/fixtures/recipes/no_name/recipe.yml b/core/tests/fixtures/recipes/no_name/recipe.yml
new file mode 100644
index 0000000000..65daa60d08
--- /dev/null
+++ b/core/tests/fixtures/recipes/no_name/recipe.yml
@@ -0,0 +1 @@
+type: 'Testing'
diff --git a/core/tests/fixtures/recipes/no_recipe/.gitkeep b/core/tests/fixtures/recipes/no_recipe/.gitkeep
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/core/tests/fixtures/recipes/recipe_include/config/node.type.another_test.yml b/core/tests/fixtures/recipes/recipe_include/config/node.type.another_test.yml
new file mode 100644
index 0000000000..48a9258b63
--- /dev/null
+++ b/core/tests/fixtures/recipes/recipe_include/config/node.type.another_test.yml
@@ -0,0 +1,9 @@
+langcode: en
+status: true
+name: 'Another test content type'
+type: another_test
+description: 'Another test content type from a recipe'
+help: ''
+new_revision: true
+preview_mode: 1
+display_submitted: true
diff --git a/core/tests/fixtures/recipes/recipe_include/recipe.yml b/core/tests/fixtures/recipes/recipe_include/recipe.yml
new file mode 100644
index 0000000000..a81aa075c0
--- /dev/null
+++ b/core/tests/fixtures/recipes/recipe_include/recipe.yml
@@ -0,0 +1,6 @@
+name: 'Recipe include'
+type: 'Testing'
+recipes:
+  - install_node_with_config
+install:
+  - dblog
diff --git a/core/tests/fixtures/recipes/recipe_include_missing/recipe.yml b/core/tests/fixtures/recipes/recipe_include_missing/recipe.yml
new file mode 100644
index 0000000000..b80db734fb
--- /dev/null
+++ b/core/tests/fixtures/recipes/recipe_include_missing/recipe.yml
@@ -0,0 +1,7 @@
+name: 'Recipe include'
+type: 'Testing'
+recipes:
+  - recipe_include
+  - does_not_exist
+install:
+  - config_test
diff --git a/core/tests/fixtures/recipes/theme_with_module_dependencies/recipe.yml b/core/tests/fixtures/recipes/theme_with_module_dependencies/recipe.yml
new file mode 100644
index 0000000000..550c3610a9
--- /dev/null
+++ b/core/tests/fixtures/recipes/theme_with_module_dependencies/recipe.yml
@@ -0,0 +1,5 @@
+name: 'Theme with module dependencies'
+type: 'Testing'
+install:
+  - test_theme_depending_on_modules
+  - test_module_required_by_theme
diff --git a/core/tests/fixtures/recipes/unmet_config_dependencies/config/node.type.test.yml b/core/tests/fixtures/recipes/unmet_config_dependencies/config/node.type.test.yml
new file mode 100644
index 0000000000..f41e7b3c1b
--- /dev/null
+++ b/core/tests/fixtures/recipes/unmet_config_dependencies/config/node.type.test.yml
@@ -0,0 +1,12 @@
+langcode: en
+status: true
+name: 'Test content type'
+type: test
+description: 'Test content type from a recipe'
+help: ''
+new_revision: true
+preview_mode: 1
+display_submitted: true
+dependencies:
+  config:
+    - core.date_format.non_existent
diff --git a/core/tests/fixtures/recipes/unmet_config_dependencies/recipe.yml b/core/tests/fixtures/recipes/unmet_config_dependencies/recipe.yml
new file mode 100644
index 0000000000..e90fca9157
--- /dev/null
+++ b/core/tests/fixtures/recipes/unmet_config_dependencies/recipe.yml
@@ -0,0 +1,2 @@
+name: 'Unmet config dependencies'
+type: 'Testing'
